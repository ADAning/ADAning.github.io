<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="计算机网络-自顶向下, DaNing的博客"><meta name="description" content="DaNing的个人博客."><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>计算机网络-自顶向下 | DaNing的博客</title><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/favicon.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/css/matery.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/css/my.css"><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">DaNing的博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>时间轴</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-tools" style="zoom:.6"></i> <span>工具</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/shortcut"><i class="fas fa-rocket" style="margin-top:-20px;zoom:.6"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu"><i class="fas fa-wheelchair" style="margin-top:-20px;zoom:.6"></i> <span>帮你百度</span></a></li><li><a href="/markdown"><i class="fab fa-markdown" style="margin-top:-20px;zoom:.6"></i> <span>Markdown</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">DaNing的博客</div><div class="logo-desc">DaNing的个人博客.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-tools"></i> 工具 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/shortcut" style="margin-left:75px"><i class="fa fas fa-rocket" style="position:absolute;left:50px"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu" style="margin-left:75px"><i class="fa fas fa-wheelchair" style="position:absolute;left:50px"></i> <span>帮你百度</span></a></li><li><a href="/markdown" style="margin-left:75px"><i class="fa fab fa-markdown" style="position:absolute;left:50px"></i> <span>Markdown</span></a></li></ul></li></ul></div></div></nav></header><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/featureimages/20.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">计算机网络-自顶向下</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E9%9D%A2%E8%AF%95/"><span class="chip bg-color">面试</span> </a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">计算机基础</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-08-04</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-03-27</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 26.6k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 95 分</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p>计网复习笔记, 参考书籍为<a href="[https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/9362103?fr=aladdin](https://baike.baidu.com/item/计算机网络自顶向下方法/9362103?fr=aladdin)">自顶向下</a>.</p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p>这里的概念都比较散, 大多是一些计网的基础概念和整体知识的框架.</p><p><strong>计算机网络的功能:</strong></p><ol><li>数据通信</li><li>资源共享</li><li>分布式处理</li><li>提高可靠性</li><li>负载均衡</li></ol><p><strong>计算机网络的分类(距离分):</strong></p><ul><li>广域网 - 长距离通信, 几十千米到几千千米</li><li>城域网 - 覆盖几个街区或城市</li><li>局域网 - 短距离通信, 几十米到几千米</li><li>个人区域网 - WPAN, 直径十米</li></ul><p><strong>传输类型分类</strong>: 广播式, 点对点</p><p><strong>主机间的通信方式</strong>: C/S, P2P</p><p><strong>协议</strong>: 定义了在两个或多个通信实体之间交换的<strong>报文格式</strong>和<strong>次序</strong>, 以及在报文传输和接收或其它事件方面所采取的<strong>动作</strong>.</p><p><strong>三种交换方式的区别?</strong></p><blockquote><p>电路交换: 整个报文的比特流从源点连续的直达终点, 像在一个管道中传输. 包括建立连接, 传输数据和断开连接三个阶段. 最典型的电路交换网络是传统电话网络.</p><p>报文交换: 将整个报文转发到相邻节点, 全部存储下来, 查找转发表, 转发到下一个节点. 是<strong>存储-转发</strong>类型的网络.</p><p>分组交换: 将报文分组转发到相邻节点, 查找转发表, 转发到下一个节点. 也是<strong>存储-转发</strong>类型的网络. 网络核心是分组交换.</p></blockquote><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/交换方式.jpg" style="zoom:50%"><p><strong>接入网络的三种方式</strong>:</p><ul><li><p>住宅接入: modem, xDSL, HFC</p></li><li><p>公司: LAN</p></li><li><p>无线接入: Wireless LAN, Wireless WAN</p></li></ul><p><strong>物理媒体</strong>:</p><ul><li>引导型: 带线的, 光纤, 双绞线, 同轴电缆</li><li>非引导性: 波类的, 无线, 卫星</li></ul><p><strong>主要性能指标:</strong></p><ol><li><p><strong>带宽(Bandwidth)</strong>: 本来表示通信线路允许通过的信号频带范围, 但在计算机网络中, 带宽表示网络的通信线路所能 传送数据的能力, 是数字信道所能传送的”最高数据率”的同义词, 单位是比特/秒( b/s).</p></li><li><p><strong>时延(Delay)</strong>:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/延时.jpg" style="zoom:50%"></li><li><p><strong>时延带宽积</strong>: 指发送端发送的第一个比特即将到达终点时, 发送端已经发送了多少个比特, 因此又称以比特为单位的链路长度, 即<strong>时延带宽积 = 传播时延 * 信道带宽</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/时延带宽积.jpg" style="zoom:50%"><p><strong>流量强度约为0时, 平均排队时延小, 趋于1时时延变大, 大于1时平均时延无穷大</strong>.</p></li></ol><p><strong>计算机网络提供的服务的三种分类</strong>:</p><ol><li><p><strong>面向连接服务与无连接服务</strong></p><p>在面向连接服务中, 通信前双方必须先建立连接, 分配相应的资源( 如缓冲区) , 以保证通信能正常进行, 传输结束后释放连接和所占用的资源. 因此这种服务可以分为连接建立, 数据传输和连接释放三个阶段. 例如TCP就是一种面向连接服务的协议. 在无连接服务中, 通信前双方不需要先建立连接, 需要发送数据时可直接发送, 把每个带有目的地址的包( 报文分组) 传送到线路上, 由系统选定路线进行传输. 这是一种不可靠的服务. 这种服务常被描述为”尽最大努力交付”(Best-Effort-Delivery), 它并不保证通信的可靠性. 例如 IP, UDP就是一种无连接服务的协议.</p></li><li><p><strong>可靠服务和不可靠服务</strong></p><p>可靠服务是指网络具有纠错, 检错, 应答机制, 能保证数据正确, 可靠地传送到目的地. 不可靠服务是指网络只是尽晕正确, 可靠地传送, 而不能保证数据正确, 可靠地传送到目的地, 是一种尽力而为的服务. 对于提供不可靠服务的网络, 其网络的正确性, 可靠性要由应用或用户来保障. 例如, 用户收到信息后要判断信息的正确性, 如果不正确, 那么用户要把出错信息报告给信息的发送者, 以便发送者采取纠正措施. 通过用户的这些措施, 可以把不可靠的服务变成可靠的服务.</p></li><li><p><strong>有应答服务和无应答服务</strong></p><p>有应答服务是指接收方在收到数据后向发送方给出相应的应答, 该应答由传输系统内部自动实现, 而不由用户实现. 所发送的应答既可以是肯定应答, 也可以是否定应答, 通常在接收到的数据有错误时发送否定应答. 例如, 文件传输服务就是一种有应答服务. 无应答服务是指接收方收到数据后不自动给出应答. 若需要应答, 则由高层实现. 例如, 对于WWW服务, 客户端收到服务器发送的页面文件后不给出应答.</p></li></ol><p><strong>网络分层</strong>:</p><p><strong>层次划分是根据功能划分的, 与实现的方法无关</strong>. 譬如RIP协议是网络层协议, 但却是通过应用层和传输层来实现的.</p><p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/iso_osi.jpg" alt=""></p><p><strong>五层协议</strong></p><blockquote><p>应用层 : 为特定应用程序提供数据传输服务, 例如 HTTP, DNS 等协议. 数据单位为报文.</p><p>传输层 : 为进程提供通用数据传输服务. 由于应用层协议很多, 定义通用的传输层协议就可以支持不断增多的应用层协议. 运输层包括两种协议: 传输控制协议 TCP, 提供面向连接, 可靠的数据传输服务, 数据单位为报文段, 用户数据报协议 UDP, 提供无连接, 尽最大努力的数据传输服务, 数据单位为用户数据报. TCP 主要提供完整性服务, UDP 主要提供及时性服务. ( 流量控制, 差错控制, 服务质量, 数据传输管理, 端到端)</p><p>网络层 : 为主机提供数据传输服务. 而传输层协议是为主机中的进程提供数据传输服务. 网络层把传输层传递下来的报文段或者用户数据报封装成分组. ( 流量控制, 拥塞控制, 差错控制, 网 际互联)</p><p>链路层 : 网络层针对的还是主机之间的数据传输服务, 而主机之间可以有很多链路, 链路层协议就是为同一链路的主机提供数据传输服务. 数据链路层把网络层传下来的分组封装成帧. ( 封装成帧, 差错控制, 流量控制, 传输管理)</p><p>物理层 : 考虑的是怎样在传输媒体上传输数据比特流, 而不是指具体的传输媒体. 物理层的作用是尽可能屏蔽传输媒体和通信手段的差异, 使数据链路层感觉不到这些差异.</p></blockquote><p><strong>OSI(七层协议)</strong></p><blockquote><p>表示层 : 数据压缩, 加密以及数据描述, 这使得应用程序不必关心在各台主机中数据内部格式不同的问题.</p><p>会话层 : 建立及管理会话.</p><p>五层协议没有表示层和会话层, 而是将这些功能留给应用程序开发者处理.</p></blockquote><p><strong>端到端</strong>: 端到端通信建立在点到点通信的基础上, 它是由一段段的点到点通信信道构成的, 是比点到 点通信更高一级的通信方式, 以完成应用程序( 进程) 之间的通信. “端” 是指<strong>用户程序的端口</strong>, 端口号标识了应用层中<strong>不同的进程</strong>.</p><p><strong>点到点</strong>: 直接相连的结点之间的通信称为点到点通信, 它只<strong>提供一台机器到另一台机器之间的通信</strong>, 不涉及程序或进程的概念. 同时, 点到点通信并不能保证数据传输的可靠性, 也不能说明源主机与目的主机之间是哪两个进程在通信, 这些工作都是由网络层来完成的.</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层讲解了与用户距离最近的网络应用, 网络应用才是计算机网络存在的原因. 应用层传输数据的单位是<strong>报文(message)</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/应用层框架.jpg" style="zoom:67%"><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h3><p>WEB网页是由一些<strong>对象</strong>该组成的, HTML文件涵盖了网页源码, 其中就包括其他媒体流文件对象的链接. 每个对象都能通过<code>URL</code>进行标识.</p><blockquote><p><a href="http://www.someschool.edu/someDept/pic.gif" target="_blank" rel="noopener">www.someschool.edu/someDept/pic.gif</a></p></blockquote><p>HTTP(HyperText Transfer Protocol, 超文本传输协议): HTTP定义了浏览器(万维网客户进程) 怎样向万维网服务器请求万维网文档, 以及服务器怎样把文档传送给浏览器. 从层次的角度看, HTTP 是面向事务的(Transaction-oriented) 应用层协议, 它规定了在浏览器和服务器之间的请求和响应的格式与规则, 是万维网上能够可靠地交换文件( 包括文本, 声音, 图像等各种多媒体文件) 的重要基础.</p><p>HTTP使用TCP, 端口号80, 也是无状态的(不保存用户过去的使用信息, Cookie可以解决). 有持久和非持久连接方式. 不同连接方式下所需传输文件的时间必定是不一样的. 定义了<strong>往返时延</strong>作为衡量标准.</p><p><strong>往返时延RRT的定义</strong>: 从客户机到服务器发送一个小分组并返回所历经的时间.</p><p>假设当前网页有1个HTML对象, 3个JPG对象, 1个Audio对象, 共计5个对象.</p><p><strong>非持久</strong>: 每个对象都建立连接, 然后再传输.</p><p><strong>持久 - 非流水线</strong>: 先建立一次连接, 之后串行地传输每个对象, 超时关闭.</p><p><strong>持久 - 流水线</strong>: 建立连接后, 并行的传输每个对象, 并认为所有对象发送时间约为1个RTT. 但是必须先传输HTML对象, 所以多个对象传输也可以认为总共是3个RTT. 超时关闭.</p><table><thead><tr><th>连接方式</th><th>所需RTT</th><th>公式</th></tr></thead><tbody><tr><td>非持久</td><td>5 * 2 RTT = 10 RTT</td><td>2n RTT</td></tr><tr><td>持久 - 非流水线</td><td>(5 + 1)RTT = 6 RTT</td><td>(n + 1) RTT</td></tr><tr><td>持久 - 流水线</td><td>2 / 3 RTT</td><td>2 / 3 RTT</td></tr></tbody></table><p>请求头:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/http请求头.jpg" style="zoom:50%"><p>响应头:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/http响应头.jpg" style="zoom:50%"><h3 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h3><p>FTP(File Transfer Protocol, 文件传输协议): C/S模式的文件传输协议, 因为控制端口和数据端口不是在一起, 所以实现了<strong>带外传输</strong>. 采用的是<strong>TCP协议</strong>.</p><p><strong>控制端口</strong>: 21</p><p><strong>数据端口</strong>: 20</p><p>过程:</p><ol><li>客户机通过控制连接获得授权</li><li>客户机经控制连接通过发送命令浏览远程目录</li><li>当服务器接收到一个文件传输命令时, 该服务器打开到客户机的一个数据连接</li><li>在传输一个文件后, 服务器关闭连接</li></ol><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><p>电子邮件协议主要有<strong>SMTP, POP3, IMAP</strong>.</p><p>电子邮件主要由三个部分组成: <strong>用户代理</strong>, <strong>邮件服务器</strong>, <strong>邮件传输协议</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/电子邮件.jpg" style="zoom:50%"><p><strong>用户代理</strong>: 也叫作邮件阅读器. 用户查看电子邮件就用的是这种应用程序.</p><p><strong>邮件服务器</strong>: 用户邮件的信息托管在邮件服务器上, 也同样负责用户邮件的发送(通过一个发送队列实现).</p><p><strong>邮件传输协议</strong>: 邮件服务器见传输邮件通过邮件传输协议来规定格式.</p><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>简单邮件传输协议(Simple Mail Transfer Protocol, SMTP) 是一种提供可靠且有效的电子邮件传输的协议, 它控制两个相互通信的SMTP 进程交换信息. 由于SMTP 使用客户／服务器方式, 因此负责发送邮件的SMTP 进程就是SMTP 客户, 而负责接收邮件的SMTP 进程就是SMTP 服务器. <strong>SMTP 用的是TCP 连接, 端口号为25.</strong></p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/smtp.jpg" style="zoom:80%"><ol><li>Alice使用UA写作报文并向 <a href="mailto:bob@someschool.edu">bob@someschool.edu</a>发送.</li><li>Alice的UA向其邮件服务器发送报文, 报文放置在报文队列中.</li><li>SMTP的客户机侧打开与Bob的邮件服务器的TCP连接.</li><li>SMTP通过TCP连接发送Alice的报文.</li><li>Bob的邮件服务器将该报文放入Bob的邮箱.</li><li>Bob调用其用户代理来读报文.</li></ol><p><strong>通信三阶段</strong>:</p><ul><li>握手</li><li>报文传输</li><li>关闭</li></ul><p>交互实例:</p><blockquote><p>S: 220 hamburger.edu<br>C: HELO crepes.fr<br>S: 250 Hello crepes.fr, pleased to meet you<br>C: MAIL FROM: <a href="mailto:&#x61;&#108;&#105;&#x63;&#x65;&#64;&#x63;&#114;&#x65;&#112;&#x65;&#x73;&#46;&#102;&#x72;">&#x61;&#108;&#105;&#x63;&#x65;&#64;&#x63;&#114;&#x65;&#112;&#x65;&#x73;&#46;&#102;&#x72;</a><br>S: 250 <a href="mailto:alice@crepes.fr">alice@crepes.fr</a>… Sender ok<br>C: RCPT TO: <a href="mailto:&#x62;&#111;&#x62;&#x40;&#104;&#x61;&#109;&#x62;&#x75;&#114;&#103;&#101;&#x72;&#46;&#x65;&#100;&#117;">&#x62;&#111;&#x62;&#x40;&#104;&#x61;&#109;&#x62;&#x75;&#114;&#103;&#101;&#x72;&#46;&#x65;&#100;&#117;</a><br>S: 250 <a href="mailto:bob@hamburger.edu">bob@hamburger.edu</a> … Recipient ok<br>C: DATA<br>S: 354 Enter mail, end with “.” on a line by itself<br>C: Do you like ketchup?<br>C: How about pickles?<br>C: .<br>S: 250 Message accepted for delivery<br>C: QUIT<br>S: 221 hamburger.edu closing connection</p></blockquote><p>由于SMTP比较早, 不能兼容国内的文字和其他多媒体流. <strong>报文必须以7比特ASCII格式</strong>.</p><p><strong>SMTP与HTTP的异同</strong>:</p><table><thead><tr><th>属性</th><th>HTTP</th><th>SMTP</th></tr></thead><tbody><tr><td>协议</td><td>TCP</td><td>TCP</td></tr><tr><td>端口号</td><td>80</td><td>25</td></tr><tr><td>推拉</td><td>拉</td><td>推</td></tr><tr><td>对象封装</td><td>每个对象用响应报文分别封装</td><td>所有对象封装成一个响应报文</td></tr><tr><td>限制</td><td>没有报文限制</td><td>必须用7位ASCII格式</td></tr></tbody></table><p><strong>邮件报文格式</strong>:</p><blockquote><p>—首部行—</p><p>TO:</p><p>From:</p><p>Subject:</p><p>—主体—</p><p>Body:</p></blockquote><p><strong>MIME</strong>: 多媒体邮件扩展, 能采用多种编码格式和编码数据的方法.</p><h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>POP3直接看一个例子:</p><blockquote><p>— 特许阶段 — 对用户信息进行认证</p><p>S: +OK POP3 服务器 ready<br>C: user bob<br>S: +OK<br>C: pass hungry<br>S: +OK user successfully logged on</p><p>— 事务阶段 — 用简单的命令执行操作</p><p>C: list<br>S: 1 498 -&gt; content length<br>S: 2 912<br>S: .<br>C: retr 1<br>S: &lt;message 1 contents&gt;<br>S: .<br>C: dele 1<br>C: retr 2<br>S: &lt;message 1 contents&gt;<br>S: .<br>C: dele 2<br>C: quit<br>S: +OK POP3 服务器 signing off</p><p>— 更新阶段 — 用户离线后, 服务器进行内容更新</p></blockquote><p>POP3有<code>Download and delete</code>和<code>Download and keep</code>两种模式, 当<code>Download and delete</code>时, 阅读完内容后会在服务器中删除. <code>Download and keep</code>时, 每次阅读都会下载所有的邮件到本地, 不删除邮箱内容.</p><h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP把所有的报文信息都<strong>保存在服务器</strong>上, 并<strong>允许用户组织文件夹</strong>. 保存文件夹名和报文ID和文件夹名之间的映射.</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS(Domain Name System): 域名解析是指把<strong>域名映射成为IP 地址或把IP 地址映射成域名的过程</strong>. 前者称为正向解析, 后者称为反向解析. 当客户端需要域名解析时, 通过本机的DNS 客户端构造一个DNS 请求报文, 以UDP数据报方式发往本地域名服务器. DNS是由分布式数据库实现的, 集中式DNS容易产生<strong>单点故障</strong>, 而且不利于维护, 当查询量很大的时候也不能进行负载分配. <strong>端口号53</strong>, <strong>书中唯一一个UDP协议的应用</strong>.</p><p><strong>等级制数据库的DNS查询过程</strong>:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/dns分布式.jpg" style="zoom:67%"><p>假设客户机要求<a href="http://www.amazon.com" target="_blank" rel="noopener">www.amazon.com</a> 的IP地址:</p><ol><li>客户机请求根服务器以发现com DNS服务器</li><li>客户机请求com DNS服务器以得到 amazon.com DNS 服务器</li><li>客户机请求amazon.com DNS服务器以得到对 <a href="http://www.amazon.com的ip/" target="_blank" rel="noopener">www.amazon.com</a><a href="http://www.amazon.com的ip/" target="_blank" rel="noopener">的</a><a href="http://www.amazon.com的ip/" target="_blank" rel="noopener">IP</a>地址</li></ol><p><strong>分布式DNS服务器</strong>:</p><ul><li>根名字服务器: 当本地名字服务器不能分解名字时联系它, 如果名字映射未知, 联系权威名字服务器.</li><li>顶级域服务器: 负责com, org, net, edu等, 以及所有顶级国家域 uk, fr, ca, jp.</li><li>权威DNS服务器: 组织的DNS 服务器为组织的服务器(如Web和电子邮件)提供对IP映射的权威主机名. 能够由组织或服务提供商维护.</li><li>本地名字服务器: 并不严格属于等级结构, 当主机发出DNS请求时, 请求被发送到其本地名字服务器, 作为代理, 将请求转发到等级结构.</li></ul><p><strong>DNS查询方式</strong>:</p><ul><li>递归请求: 搜索上类似与<strong>DFS</strong>, “我不知道该名字, 但我可以帮你问问别的服务器”. 会带来沉重的查询负担.</li><li>迭代请求: 搜索上类似与<strong>BFS</strong>, “我不知道该名字, 但你应该问问这个服务器”.</li></ul><p>应用层APP的协议和端口号:</p><table><thead><tr><th>Protocol</th><th>Port number</th><th>Transport layer protocol</th></tr></thead><tbody><tr><td>HTTP</td><td>80</td><td>TCP</td></tr><tr><td>FTP</td><td>21(control)/20(data)</td><td>TCP</td></tr><tr><td>SMTP</td><td>25</td><td>TCP</td></tr><tr><td>POP3</td><td>110</td><td>TCP</td></tr><tr><td>IMAP</td><td>143</td><td>TCP</td></tr><tr><td>DNS</td><td>53</td><td>UDP</td></tr></tbody></table><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层已经对上一层, 也就是应用层传输过来的报文进行第二层封装(抽象), 为<strong>进程</strong>提供通用数据传输服务. 从通信和信息处理的角度看, 传输层向它上面的应用层提供通信服务, 它属于面向通信部分的最高层, 同时也是用户功能中的最低层. 传输层位于网络层之上, 它为运行在不同主机上的进程之间提供了逻辑通信, 而网络层提供主机之间的逻辑通信. 显然, 即使网络层协议不可靠( 网络层协议使分组丢失, 混乱或重复) , 传输层同样能为应用程序提供可靠的服务. 对应的传输层协议就只有两个, TCP和UDP. 在传输层, 传输数据所用的单位是<strong>报文段(segment)</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/传输层框架.jpg" style="zoom:67%"><p><strong>传输层的功能</strong>:</p><ol><li>传输层提供应用进程之间的逻辑通信( 即<strong>端到端</strong>的通信) . 与网络层的区别是, 网络层提供的是主机之间的逻辑通信. 从网络层来说, 通信的双方是两台主机, IP 数据报的首部给出了这两台主机的IP地址. 但”两台主机之间的通信”实际上是两台主机中的应用进程之间的通信, 应用进程之间的通信又称端到端的逻辑通信.</li><li><strong>复用和分用</strong>. 复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据, 分用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程.</li><li>传输层还要对收到的报文进行<strong>差错检测</strong>( 首部和数据部分) . 而网络层只检查IP 数据报的首部, 不检验数据部分是否出错.</li><li>提供两种不同的传输协议, 即面向连接的TCP 和无连接的UDP . 而网络层无法同时实现两种协议( 即在网络层要么只提供面向连接的服务, 如虚电路, 要么只提供无连接服务, 如数据报, 而不可能在网络层同时存在这两种方式) .</li></ol><p><strong>多路复用和多路分解</strong>:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/多路复用和分解.jpg" style="zoom:50%"><ul><li><strong>多路复用</strong>: 从源主机的不同socket中收集数据块, 并为每个数据块封装上首部信息从而生成报文段, 将报文段传递到网络层的工作.</li><li><strong>多路分解</strong>: 将运输层报文段中的数据交付到正确的socket的工作.</li></ul><p>套接字就像<strong>门</strong>一样, 不同的进程有不同的套接字. 进程从/来自它的套接字发送/接收报文.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/socket.jpg" style="zoom:50%"><p><strong>标识套接字唯一的方法</strong>:</p><p><strong>UDP套接字</strong>: 目的地IP地址, 目的地端口号组成的二元组.</p><p><strong>TCP套接字</strong>: 源IP地址, 源端口号, 目的IP地址, 目的端口号组成的四元组.</p><p>无论是UDP还是TCP, 报文段结构都有16位源端口, 16位目的端口.</p><p><strong>IP地址从在哪获取呢? 报文段中并没有包含IP相关的内容. 但不要忘记多路复用和多路分解, 在多路分解时数据是由网络层以数据报形式往上传输的, 在去掉封装的头部后传输层一定能够知道源IP和目标IP.</strong></p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP(用户数据报协议):</p><ol><li>UDP 无须建立连接. 因此UDP 不会引入建立连接的时延. 试想如果DNS 运行在TCP 而非UDP 上, 那么DNS 的速度会慢很多. HTTP 使用TCP 而非UDP, 是因为对于基于文本数据的Web网页来说可靠性是至关重要的</li><li>无连接状态. TCP 需要在端系统中维护连接状态. 此连接状态包括接收和发送缓存, 拥塞控制参数和序号与确认号的参数. 而UDP 不维护连接状态, 也不跟踪这些参数. 因此, 某些专用应用服务器使用UDP 时, 一般都能支持更多的活动客户机.</li><li>分组首部开销小. <strong>TCP 有20B 的首部开销, 而UDP 仅有8B(32*2bit/8)的开销</strong>.</li><li>应用层能更好地控制要发送的数据和发送时间. UDP 没有拥塞控制, 因此网络中的拥塞不会影响主机的发送效率. 某些实时应用要求以稳定的速度发送, 能容忍一些数据的丢失, 但不允许有较大的时延, 而UDP 正好满足这些应用的需求. UDP 常用于一次性传输较少数据的网络应用如 DNS , SNMP 等, 因为对千这此应用, 若采用TCP, 则将为连接创建, 维护和拆除带来不小的开销. UDP 也常用于多媒体应用( 如IP 电话, 实时视频会议, 流媒体等) , 显然, 可靠数据传输对 这些应用来说并不是最重要的, 但TCP的拥塞控制会导致数据出现较大的延迟, 这是它们不可容忍的.</li></ol><p>UDP 提供尽最大努力的交付, 即不保证可靠交付, 但这并不意味着应用对数据的要求是不可靠的, 因此所有维护传输可靠性的工作需要用户在应用层来完成. 应用实体可以根据应用的需求来灵活设计自己的可靠性机制. 所以UDP常应用在对丢包率可以容忍, 对速率敏感的应用, 即使发生很小一部分的丢包, 仍然不影响用户的体验.</p><h4 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构:"></a>报文段结构:</h4><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/udp报文段.jpg" style="zoom:50%"><p>除了TCP/UDP必备的源端口和目的端口号, UDP有检查和. 检查和能够在传输的报文段中检测一位比特的差错. 发送方将报文段所有内容分批处理多个16位的整数序列, <strong>逐一加和, 进行回卷, 最后取反.</strong></p><h4 id="检查和"><a href="#检查和" class="headerlink" title="检查和:"></a>检查和:</h4><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/udp检查和.jpg" style="zoom:50%"><p>接收方也计算和, 看与发送方告诉自己的检查和累加后是否为<code>1111 1111 1111 1111</code>, 如果是的话说明<strong>没有检测出错误(检查和并不能检测到所有错误)</strong>, 如果不是则说明存在错误.</p><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p>可靠数据传输是后面TCP协议能够支持可靠性的设计依据. IP在网络层一定是不可靠的, 为什么说UDP/IP是不可靠的, 而TCP/IP就可靠了? 正是因为下层的传输的不可靠, 所以我们可以通过上层的可靠传输协议来淘汰甚至纠正不可靠的数据. 当然可靠一定伴随着代价, 也就是时间开销和资源开销.</p><p>可靠象征着接收到的字节流是<strong>完整</strong>, <strong>无差错</strong>, <strong>有序</strong>的. (TCP和UDP都没有保证最低的传输速率!)</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/可靠数据传输.jpg" style="zoom:67%"><h4 id="Rdt1-0"><a href="#Rdt1-0" class="headerlink" title="Rdt1.0"></a>Rdt1.0</h4><p>仅考虑理想化的, 无比特错误, 无丢包. 接收方完全不需要其他额外数据.</p><h4 id="Rdt2-0"><a href="#Rdt2-0" class="headerlink" title="Rdt2.0"></a>Rdt2.0</h4><p>假设在分组的传输, 传播或缓存过程中具有比特差错, 但无丢包.</p><ul><li>解决方法: ARQ协议( 自动重传请求) , 用以下3种协议来处理<ol><li>差错检测( 接收方) : 检验和</li><li>反馈<ul><li>接收方—&gt;确认: 告诉发送方数据包有无错误, 返回肯定应答ACK 与否定应答NAK</li><li>发送方—&gt;决定下一步动作</li></ul></li><li>重传( 发送方) : 发送方重发</li></ol></li><li>与之类似的协议被称为: 停止等待协议(只有发送成功, 才发送给下一个分组, 否则一直重复)</li></ul><h4 id="Rdt2-1"><a href="#Rdt2-1" class="headerlink" title="Rdt2.1"></a>Rdt2.1</h4><p>在Rdt2.0的基础上, 考虑ACK与NAK本身出现错误的情况.</p><ul><li>无其它动作: 无法解决.</li><li>增加足够的比特, 发送方可检错与纠错.</li><li>当不能确认是ACK还是NAK时, 发送方重发: 引入冗余分组, 接收方混淆？</li><li>解决方法: 加入1bit序号(sequence number), 因为发送是交替进行的, 所以引入0和1两个数字就能说明发包的顺序.</li></ul><h4 id="Rdt2-2"><a href="#Rdt2-2" class="headerlink" title="Rdt2.2"></a>Rdt2.2</h4><p>无NAK的可靠数据传输协议, 用冗余的ACK来代替了多余的NAK. 从逻辑角度来想, 冗余ACK就代表了发送方没有收到接收方接收的响应, 那么一定是出了问题, 也就是NAK的作用.</p><ul><li>接收方必须包括由一个ACK报文确认的分组序号, 即对上次正确接收的分组的ACK.</li></ul><h4 id="Rdt3-0"><a href="#Rdt3-0" class="headerlink" title="Rdt3.0"></a>Rdt3.0</h4><p>不光考虑Rdt2.0比特差错的基础上, 还考虑底层信道的丢包.</p><ul><li>定时器( 倒计数器)<ul><li>时间值: RTT+时延</li><li>发送后, 启动定时器</li><li>响应定时器中断</li><li>终止定时器</li></ul></li><li>功能正确的协议</li><li>使用检验和, 序号, 肯定和否定确认, 定时器技术</li><li>效率低下(停止等待协议需要等待对方应答才能发下一个, 这个空闲时间很长, 就导致了时间上的利用率非常低, 后面通过流水线协议提升了效率)</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/停等协议.jpg" style="zoom:50%"><h5 id="无丢包时的运行"><a href="#无丢包时的运行" class="headerlink" title="无丢包时的运行"></a>无丢包时的运行</h5><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/rdt3无丢包.jpg" style="zoom:50%"><h5 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h5><p>因为发送分组1时发生了丢失, 在计时器期间没收到接收方的应答. 计时器超时了, 所以发送方再次发送相同的分组1.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/rdt3分组丢失.jpg" style="zoom:50%"><h5 id="ACK丢失"><a href="#ACK丢失" class="headerlink" title="ACK丢失"></a>ACK丢失</h5><p>因为接收方对发送方分组1的ACK丢失了, 发送方在计时器时间内迟迟等不来响应, 超时后发送方重发.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/rdt3ack丢失.jpg" style="zoom:50%"><h5 id="过早超时"><a href="#过早超时" class="headerlink" title="过早超时"></a>过早超时</h5><p>在发送分组1后, 可能因为网速的原因, 接收方给发送方的ACK比较晚的到达了. 接收方接收到两次相同的冗余分组, 也就是说发送方有不必要的重传. 如果某个报文段的发送过程被延迟较长时间但并未丢失, 这种情况叫做过早超时.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/rdt3过早超时.jpg" style="zoom:50%"><h4 id="流水线协议"><a href="#流水线协议" class="headerlink" title="流水线协议"></a>流水线协议</h4><p>在Rdt3.0中知道, 其效率是十分低下的. 原因就是发送方必须等待接收方的响应才能继续发送下一个分组. 为什么必须要等待响应才能发下一个分组呢? 如果连续发一串分组出去就能提升效率了, 但是要增加一些资源开销, 比如说要区分分组发出去的先后顺序必须要扩大序号的范围, 而且考虑到接收方处理分组的速度之间的差异, 必须在接收方和发送方之间引入缓冲区. 还要考虑发送方可能发送非按序到达的数据的问题.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/流水线协议.jpg" style="zoom:50%"><p>为解决上述基本问题, 引入了两种方法, 分别是<strong>GBN(Go-Back-N, 滑动窗口协议)</strong>和<strong>SR(选择重传)</strong>.</p><h5 id="Go-Back-N"><a href="#Go-Back-N" class="headerlink" title="Go-Back-N"></a>Go-Back-N</h5><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/gbn.jpg" style="zoom:50%"><ul><li>允许发送多个分组而不需要等待确认, 受限于窗口长度N.</li><li><strong>累积确认</strong>: 接收方返回的ACK号代表的含义是”<strong>该号和该号之前的分组已经成功收到</strong>“.</li><li>窗口共享计时器, 当最早发出去未被响应的分组超时则重传所有分组.</li><li>数据按序交付, <strong>失序则丢弃</strong>.</li><li><strong>回退机制</strong>:<ul><li>表示需要再退回来重传已发送过的 N 个分组</li><li>当通信线路质量不好和N过大时, 连续 ARQ 协议会带来负面影响</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/gbn执行.jpg" style="zoom:50%"><p>当pkt2发生丢失时, 接收方一直收到了乱序的pkt, 所以一直在不停的返回ACK1, 即”ACK1和ACK1以前的分组我已经收到了!”, 希望接收方发送ACK2. 之后收到的乱序pkt3, pkt4, pkt5全都被丢弃, 直到pkt2被发送方重新补上, 才继续发送下去.</p><h5 id="Selective-Repeat"><a href="#Selective-Repeat" class="headerlink" title="Selective Repeat"></a>Selective Repeat</h5><p>GBN改善了信道效率, 但仍然有不必要重传问题. 与GBN风格不同, 针对每个不同的分组都有不同的计时器和确认.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/sr.jpg" style="zoom:50%"><ul><li>窗口长度必须小于或等于序号空间大小的一半</li><li>逐一确认</li><li>只重发未被确认的分组(发送方定时器对每个没有确认的分组计时)</li><li>失序缓存, 但最终仍是按序交付</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/sr执行.jpg" style="zoom:50%"><h4 id="可靠数据传输机制及用途总结"><a href="#可靠数据传输机制及用途总结" class="headerlink" title="可靠数据传输机制及用途总结"></a>可靠数据传输机制及用途总结</h4><table><thead><tr><th>机制</th><th>用途和说明</th></tr></thead><tbody><tr><td>检验和</td><td>用于检测在一个传输分组中的比特错误.</td></tr><tr><td>确认</td><td>接收方用于告诉发送方一个分组或一组分组已被正确地接收到了. 确认报文通常携带着被确认的分组或多个分组的序号. 确认可以是逐个的或累积的, 这取决于协议.</td></tr><tr><td>序号</td><td>用于为发送的数据分组进行按序编号. 所接收分组的序号间的空隙可使接收方检测出丢失的分组. 具有相同序号的分组可使接收方检测出一个分组的冗余拷贝.</td></tr><tr><td>定时器</td><td>用于检测超时/重传一个分组, 可能因为该分组( 或其ACK) 在信道中丢失了. 由于当一个分组被时延但未丢失( 过早超时) , 或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时, 可能产生超时事件, 所以接收方可能会收到一个分组的多个冗余拷贝.</td></tr><tr><td>窗口, 流水线 GO-BACK-N Selective Repeat</td><td>发送方也许被限制仅发送那些序号落在一个指定范围内的分组. 通过允许一次发送多个分组但未被确认, 发送方的利用率可在停等操作模式的基础上得到增加. 我们很快将会看到, 窗口长度可根据接收方接收和缓存报文的能力或网络中的拥塞程度, 或两者情况来进行设置.</td></tr></tbody></table><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>在看完可靠数据传输后, 再去理解TCP就不困难了. TCP 是在不可靠的IP 层之上实现的可靠的数据传输协议, 它主要解决传输的可靠, 有序, 无丢失和不重复问题. TCP 是TCP/IP 体系中非常复杂的一个协议, 它更像是GBN和SR的混合体, 主要特点如下:</p><ol><li><p>TCP 是<strong>面向连接</strong>的传输层协议</p></li><li><p>每条TCP 连接只能有两个端点, 每条TCP 连接只能是<strong>点对点</strong>的( 一对一) .</p></li><li><p>TCP 提供可靠的交付服务, 保证传送的数据无差错, 不丢失, 不重复且有序.</p></li><li><p>TCP 提供<strong>全双工</strong>通信, 允许通信双方的应用进程在任何时候都能发送数据, 为此TCP 连接的两端都设有发送缓存和接收缓存, 用来临时存放双向通信的数据.</p><p>发送缓存用来暂时存放以下数据:</p><ul><li><p>发送应用程序传送给发送方TCP 准备发送的数据</p></li><li><p>TCP 已发送但尚未收到确认的数据</p></li></ul><p>接收缓存用来暂时存放以下数据:</p><ul><li>按序到达但尚未被接收应用程序收取的数据</li><li>不按序到达的数据</li></ul></li></ol><p>重传在TCP中, 当产生超时事件或者重复ACK才会被触发. 并像GBN一样采用单个重传计时器.</p><h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><p><strong>序号(seq)</strong>: 报文段中第1个数据字节在字节流中的位置编号.</p><p><strong>确认号(ACK)</strong>: 期望从对方收到下一个字节的序号, 且是累计应答. 即”<strong>我希望你下一次发从这个号开始的分组</strong>“.</p><p><strong>捎带确认</strong>: 确认号被装载在服务器到客户机的数据的报文段中.</p><p>对于失序的报文段, TCP没有明确指出, 应该是根据不同情况而定的.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcpseq和ack.jpg" style="zoom:50%"><h4 id="报文段结构-1"><a href="#报文段结构-1" class="headerlink" title="报文段结构"></a>报文段结构</h4><p>头部一共32*5/8 = 20bytes, 比UDP的8bytes冗长很多.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp报文段.jpg" style="zoom:50%"><h4 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h4><ol><li>从应用层接收数据:<ul><li>根据序号创建报文段</li><li>序号是报文段中第一个数据字节的数据流编号</li><li>如果未启动, 启动计时器 (考虑计时器用于最早的没有确认的报文段)</li></ul></li><li>超时<ul><li>重传导致超时的报文段</li><li>重新启动计时器</li></ul></li><li>收到确认<ul><li>如果确认了先前未被确认的报文段, 更新被确认的报文段序号, 如果还有未被确认的报文段, 重新启动计时器</li></ul></li></ol><h4 id="ACK产生"><a href="#ACK产生" class="headerlink" title="ACK产生"></a>ACK产生</h4><table><thead><tr><th>接收方事件</th><th>TCP接收方行为</th></tr></thead><tbody><tr><td>所期望序号的报文段按序到达. 所有在期望序号及以前的数据都已经被确认</td><td>延迟的ACK. 对另一个按序报文段的到达最多等待500 ms. 如果下一个按序报文段在这个时间间隔内没有到达, 则发送一个ACK</td></tr><tr><td>有期望序号的报文段按序到达. 另一个按序报文段等待发送ACK</td><td>立即发送单个累积ACK, 以确认两个按序报文段</td></tr><tr><td>比期望序号大的失序报文段到达, 检测出数据流中的间隔.</td><td>立即发送冗余ACK, 指明下一个期待字节的序号( 也就是间隔的低端字节序号)</td></tr><tr><td>部分或者完全填充已接收到, 数据间隔的报文段到达</td><td>倘若该报文段起始于间隔的低端, 则立即发送ACK</td></tr></tbody></table><h4 id="重传情况"><a href="#重传情况" class="headerlink" title="重传情况"></a>重传情况</h4><h5 id="丢失确认"><a href="#丢失确认" class="headerlink" title="丢失确认"></a>丢失确认</h5><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp丢失确认.jpg" style="zoom:50%"><p>主机B发送的ACK丢失, 超时后主机A重传丢失的Seq=92分组.</p><h5 id="过早超时-1"><a href="#过早超时-1" class="headerlink" title="过早超时"></a>过早超时</h5><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp过早超时.jpg" style="zoom:50%"><p>主机A在重传Seq=92分组后, 分别收到了ACK=100和ACK=120, 累计确认, 更新了应该发送的起始序号. 下次发送从Seq=120开始.</p><h5 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h5><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp累计确认.jpg" style="zoom:50%"><p>主机B响应的ACK=100丢失, 但是主机B已经收到了120以前的所有分包. 当主机A收到ACK=120时, 代表120号之前的分组主机B已经收到, 虽然没有ACK=100的响应但也无妨(累计确认). 所以下次发送新分组应该是Seq=120.</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>因为超时间隔常常相对较长, 重传丢失报文段以前有长时延. 所以引入快速重传, 如果对相同数据, 发送方收到<strong>3个重复ACK</strong>, 假定被确认的报文段以后的报文段丢失了. 在定时器超时之前就能重传.</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>为了解决发送方和接收方在速度上的不匹配, 在发送方和接收方都各自设计了缓冲区. 发送方不能发送太多, 太快的数据让接收方缓冲区溢出. 接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp缓冲区.jpg" style="zoom:67%"><p>缓冲区的剩余空间(也叫接收窗口 <code>RcvWindow</code>):<br>$$<br>\rm RcvWindow = RcvBuffer-[LastByteRcvd - LastByteRead]<br>$$<br>只要接收方的总Buffer的承载能力超过接收方已经确认的数据就能保证接收方缓冲区不溢出.</p><h4 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h4><p>三次握手, 四次挥手. 面试巨高频考点. 连接管理就是TCP为什么是面向连接的协议的原因.</p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><ol><li>客户机的TCP 首先向服务器的TCP 发送一个连接请求报文段. 这个特殊的报文段中不含应用层数据, 其首部中的SYN标志位被置为1 . 另外, 客户机会随机选择一个起始序号seq = x( 连接请求报文不携带数据, 但要消耗一个序号) .</li><li>服务器的TCP 收到连接请求报文段后, 如同意建立连接, 就向客户机发回确认, 并为该 TCP 连接分配TCP 缓存和变量. 在确认报文段中, SYN 和ACK 位都被置为1, 确认号字段的值为 x + 1, 并且服务器随机产生起始序号seq= y( 确认报文不携带数据, 但也要消耗一个序号) . 确认 报文段同样不包含应用层数据.<ul><li>这里大写的ACK和小写的ack, 其中一个是<strong>确认值</strong>, 当ACK为1时代表确定连接. 还有一个ack是<strong>确认编号</strong>, 响应seq = x + 1.</li></ul></li><li>当客户机收到确认报文段后, 还要向服务器给出确认, 并且也要给该连接分配缓存和变量. 这个报文段的ACK 标志位被置1, 序号字段为x+ 1, 确认号字段ack=y+ 1 . 该报文段可以携带数据, 若不携带数据则不消耗序号.</li></ol><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp三次握手.jpg" style="zoom:50%"><p>成功进行以上三步后, 就建立了TCP 连接, 接下来就可以传送应用层数据. TCP 提供的是全双工通信, 因此通信双方的应用进程在任何时候都能发送数据. 另外, 值得注意的是, 服务器端的资源是在完成第二次握手时分配的, 而客户端的资源是在完成第三次握手时分配的, 这就使得服务器易于受到SYN 洪泛攻击.</p><p><strong>为什么不采用”两次握手”建立连接呢？</strong></p><p>这主要是为了防止两次握手情况下已失效的连接请求报文段突然又传送到服务器而产生错误. 考虑下面这种情况. 客户A 向服务器B 发出TCP 连接请求, 第一个连接请求报文在网络的某个结点长时间滞留, A 超时后认为报文丢失, 千是再重传一次连接请求, B 收到后建立连接. 数据传输完毕后双方断开连接. 而此时, 前一个滞留在网络中的连接请求到达服务器B, 而B 认为A 又发来连接请求, 此时若使用”三次握手”, 则B 向A 返回确认报文段, 由于是一个失效的请求, 因此A 不予理睬, 建立连接失败. 若采用的是”两次握手”, 则这种情况下B 认为传输连接已经建立, 并一直 等待A 传输数据, 而A 此时并无连接请求, 因此不予理睬, 这样就造成了B的资源白白浪费.</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp四次挥手.jpg" style="zoom:50%"><ol><li>客户机打算关闭连接时, 向其TCP 发送一个连接释放报文段, 并停止发送数据, 主动关闭TCP 连接, 该报文段的FIN 标志位被置1, seq= u, 它等于前面已传送过的数据的最后一个字节的序号加1 (FIN 报文段即使不携带数据, 也要消耗一个序号) . TCP 是全双工的, 即可以想象为一条TCP 连接上有两条数据通路. 发送FIN 报文时, 发送FIN 的一端不能再发送数据, 即关闭了其中一条数据通路, 但对方还可以发送数据.</li><li>服务器收到连接释放报文段后即发出确认, 确认号是ack = u + 1, 而这个报文段自己的序号是V, 等于它前面已传送过的数据的最后一个字节的序号加1 . 此时, 从客户机到服务器这个方向的连接就释放了, TCP 连接处于半关闭状态. 但服务器若发送数据, 客户机仍要接收, 即从服务器到客户机这个方向的连接并未关闭.</li><li>若服务器已经没有要向客户机发送的数据, 就通知TCP 释放连接, 此时其发出FIN= 1 的连接释放报文段.</li><li>客户机收到连接释放报文段后, 必须发出确认. 在确认报文段中, ACK 字段被置为1, 确认号ack= w + 1, 序号seq= u + 1 . 此时TCP 连接还未释放, 必须经过时间等待计时器设置的时间 2MSL 后, A 才进入连接关闭状态.</li></ol><p><strong>为何不采用”三次握手”释放连接, 且发送最后一次握手报文后要等待2MSL 的时间呢？</strong></p><p>原因有两个:</p><ol><li>保证A 发送的最后一个确认报文段能够到达B . 如果A 不等待2MSL, 若A 返回的最后确认报文段丢失, 则B 不能进入正常关闭状态, 而A 此时已经关闭, 也不可能再重传.</li><li>防止出现”已失效的连接请求报文段”. A 在发送最后一个确认报文段后, 再经过2MSL可保证本连接持续的时间内所产生的所有报文段从网络中消失.</li></ol><p>服务器结束TCP 连接的时间要比客户机早一些, 因为客户机最后要等待2MSL 后才可进入CLOSED状态.</p><h5 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h5><p>三次握手:</p><blockquote><ol><li>SYN = 1, seq = x</li><li>SYN = 1, ACK = 1, seq = y, ack = x + 1</li><li>ACK = 1, seq = x + 1, ack = y + 1</li></ol></blockquote><p>四次挥手:</p><blockquote><ol><li>FIN = 1, seq = u</li><li>ACK = 1, seq = v, ack = u + 1</li><li>FIN = 1, ACK = 1, seq = w, ack = u + 1</li><li>ACK = 1, seq = u + 1, ack = w + 1</li></ol></blockquote><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>某段时间, 若对网络中某资源的需求超过了该资源所能提供的可用部分, 即现有的负荷超过了网络能够承受的最大负荷, 太多的源发送太多太快的数据, 使网络来不及处理, 产生拥塞(congestion). 不同于流量控制. 经常导致丢包(路由器缓冲区溢出)和高延迟(路由器缓冲区中排队). 拥塞控制是一个<strong>全局性</strong>的过程, 涉及到所有的主机, 所有的路由器, 以及与降低网络传输性能有关的所有因素.</p><p>控制拥塞有两种方法:</p><ul><li><strong>端到端的拥塞控制</strong>: 不能从网络得到明确的反馈, 从端系统根据观察到的时延和丢失现象推断出拥塞.</li><li><strong>网络辅助的拥塞控制</strong>: 路由器为端系统提供反馈.</li></ul><p>TCP采用的是端到端的拥塞控制.</p><p>设置一个拥塞窗口<code>ConWin</code>, 通过拥塞窗口来限制发送方的传输:<br>$$<br>\rm LastByteSent-LastByteAcked \leq CongWin<br>$$<br>当然这个拥塞窗口是动态的, 应该根据感知到的网络拥塞情况进行调整. 也就是当发生<strong>丢失时间, 即超时或3次冗余确认</strong>时降低拥塞窗口大小.</p><p>通过三个机制来调整拥塞窗口:</p><ul><li>AIMD - 加增倍减</li><li>慢启动</li><li>超时事件后的保守机制</li></ul><h5 id="AIMD-乘性减-加性增"><a href="#AIMD-乘性减-加性增" class="headerlink" title="AIMD 乘性减, 加性增"></a>AIMD 乘性减, 加性增</h5><ul><li>乘性减: 丢包事件后, 拥塞窗口值减半</li><li>加性增: 如没有检测到丢包事件, 每个RTT时间拥塞窗口值增加一个MSS (最大报文段长度)</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcpaimd.jpg" style="zoom:50%"><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>当连接开始的时候, 速率呈指数式上升, 直到第1次报文丢失事件发生为止.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp慢启动.jpg" style="zoom:50%"><h5 id="超时事件后的保守机制"><a href="#超时事件后的保守机制" class="headerlink" title="超时事件后的保守机制"></a>超时事件后的保守机制</h5><p>基本思想是3个冗余ACK指示网络还具有某些传送报文段的能力, 那么3个冗余ACK以前的<strong>超时</strong>,则<strong>更为”严重”</strong>.</p><p>收到3个冗余确认后:</p><ul><li>$\rm CongWin$减半</li><li>窗口再线性增加</li></ul><p>超时事件以后:</p><ul><li>$\rm CongWin$值设置为1 MSS</li><li>窗口再指数增长</li><li>到达一个阈值 (Threshold) 后, 再线性增长</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tcp超时保守.jpg" style="zoom:67%"><p>在丢包事件发生时, 阈值$\rm Threshold$设置为发生丢包以前的拥塞窗口的一半, 这样能够减轻网络压力, 到达一个相对原来比较低的阈值后线性增加.</p><p>图中先是慢启动, 在$\rm TTR$为4时到达阈值, 从指数型增长变为线性增长, 在$\rm TTR$为9时下方蓝线超时事件, 拥塞窗口置1, 阈值减半, 重新指数增加, 到达阈值后线性增加. 上方黑线发生的是3次冗余确认, 拥塞窗口减半, 之后线性增加.</p><p>拥塞控制小结:</p><ul><li><p>当$\rm CongWin &lt; Threshold$时, 发送者处于慢启动阶段, $\rm CongWin$指数增长.</p></li><li><p>当$\rm CongWin &gt; Threshold$时, 发送者处于拥塞避免阶段, $\rm CongWin$线性增长.</p></li><li><p>当出现3个冗余确认时, 阈值Threshold设置为$\rm CongWin/2$, 且$\rm CongWin$设置为$\rm Threshold$.</p></li><li><p>当超时发生时, 阈值$\rm Threshold$设置为$\rm CongWin/2$, 并且$\rm CongWin$设置为1 MSS.</p></li></ul><h3 id="TCP和UDP比较"><a href="#TCP和UDP比较" class="headerlink" title="TCP和UDP比较"></a>TCP和UDP比较</h3><table><thead><tr><th>比较项</th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>套接字</td><td>四元组</td><td>二元组</td></tr><tr><td>连接及状态</td><td>需要建立, 有状态</td><td>无需建立连接, 无状态</td></tr><tr><td>拥塞控制, 流量控制</td><td>有</td><td>无, 流量不可调节</td></tr><tr><td>分组首部开销</td><td>20字节(大)</td><td>8字节(小)</td></tr><tr><td>应用层对发送的数据和发送时间</td><td>不可控制</td><td>可控制</td></tr><tr><td>服务原则</td><td>可靠交付</td><td>尽力交付</td></tr><tr><td>传送的数据单位</td><td>报文段, 大小可变</td><td>报文, 大小不变</td></tr><tr><td>协议类型</td><td>点对点协议</td><td>可支持一对一, 一对多, 多对一和多对多</td></tr><tr><td>差错检测手段</td><td>校验和: 出错重传</td><td>校验和: 丢弃</td></tr><tr><td>应用层协议</td><td>SMTP, TELNET, FTP, HTTP, VoIP</td><td>DNS, SNMP, RIP, VoIP</td></tr></tbody></table><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层是对传输层协议的数据进行进一步封装(抽象). 无视传输层的具体内容, 以<strong>数据报(datagram)</strong>作为单位传输. 网络层研究的就是, 我知道A到B主机要传信息, 但是怎么传最好的问题. 涉及转发, 路径选择等算法. 网络层负责完成的是<strong>主机到主机间</strong>, 也就是<strong>点到点</strong>之间的通信. 实现也全是在网络内部实现的, 当IP数据报通过路由器时, 路由器检查只所有数据报的首部字段.</p><p><strong>转发</strong>: 微观上的, 一个分组从一条入链路到一台路由器中的出链路的传送, 是路由器的本地动作.</p><p><strong>选路</strong>: 宏观上的, 分组从发送方流向接收方时, 网络层决定分组从源到目的地节点所采用的路径. 涉及到一个网络中的所有路由器, 它们经选路协议共同交互才能完成.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/网络层框架.jpg" style="zoom:67%"><p>Internet采用的是数据报网络, 其网络层服务模型是尽力而为的. 没有任何的顺序, 带宽, 丢失保证. 但其他协议譬如ATM, 帧中继, X.25因为使用了虚电路, 从一定程度上保证了传输的稳定性.</p><h3 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h3><p>数据报网络能提供网络层的无连接服务, 而虚电路可以提供连接服务.</p><h4 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h4><p>虚电路名字的由来是”源到目的地路径与电话电路行为非常相似”, 其性能是明确的, 并且一定是沿着源到目的地路径的网络动作.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/虚电路.jpg" style="zoom:67%"><p>在数据流动之前, 先建立呼叫, 然后在结束时拆除. 在源到目的地路径上的每台路由器为每条经过的连接维护维护状态, 链路, 路由器资源(带宽, 缓存)可能分配给VC.</p><p>VC组成:</p><ul><li>源和目的主机之间的路径(由一系列链路和路由器组成)</li><li>VC号(VC号是标识沿路径每条链路的号码)</li><li>沿路径路由器中转发表中的项</li></ul><p>虚电路的分组的首部会携带一个VC号, 因为一条虚电路在每条链路上的VC号可能不同, 所以每次经过新的路由器, 都会分配一个新的VC号来代替原来的VC号, 新的VC号是从新的转发表中获得的.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/vc号.jpg" style="zoom:67%"><p>虚电路路由器维护的转发表形式和下表类似, 上图网络中西北处路由器的转发表为:</p><table><thead><tr><th>入接口</th><th>入VC#</th><th>出接口</th><th>出VC#</th></tr></thead><tbody><tr><td>1</td><td>12</td><td>2</td><td>22</td></tr><tr><td>2</td><td>63</td><td>1</td><td>18</td></tr><tr><td>3</td><td>7</td><td>2</td><td>17</td></tr><tr><td>1</td><td>97</td><td>3</td><td>87</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>这个转发表是路由器一定会维护的. 路由器通过存放接入口的VC#和出口的VC#之间的映射, 来完成VC#的转换.</p><h4 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h4><p>数据报网络的数据传输不依赖于”连接”, 路由器也没有端到端连接的状态.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/数据报网络.jpg" style="zoom:67%"><p>路由器也不需要维护像虚电路内容的转发表. 只需要根据数据报的目的地信息就能知道数据报应该往路由器的哪个端口发送. 所以它的转发表仅仅包含了目的地址相关的信息和链路接口两个项.</p><h5 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h5><p>因为转发表中含有的项非常多, 查找起来比较慢, 肯定不能挨个去查, 这样效率太低了. 所以它的转发表不再存储每条目的地址, 而是存储一个前缀匹配法则. 做最长的前缀匹配, 就能确定出口.</p><table><thead><tr><th>目的地址范围</th><th>链路接口</th></tr></thead><tbody><tr><td>11001000 00010111 00010000 <strong>00000000</strong> 到 11001000 00010111 00010000 <strong>11111111</strong></td><td>0</td></tr><tr><td>11001000 00010111 00011000 <strong>00000000</strong> 到 11001000 00010111 00011000 <strong>11111111</strong></td><td>1</td></tr><tr><td>11001000 00010111 00011<strong>001 00000000</strong> 到 11001000 00010111 00011<strong>111 11111111</strong></td><td>2</td></tr><tr><td>其他</td><td>3</td></tr></tbody></table><p>但是上面这个表只能确定IP范围, 还没有做到最长的前缀匹配, 上面存储的内容有些过于冗杂了.</p><table><thead><tr><th>前缀匹配</th><th>链路接口</th></tr></thead><tbody><tr><td>11001000 00010111 00010</td><td>0</td></tr><tr><td>11001000 00010111 00011000</td><td>1</td></tr><tr><td>11001000 00010111 00011</td><td>2</td></tr><tr><td>其他</td><td>3</td></tr></tbody></table><p>只要根据最符合前缀匹配式的接口进行匹配, 就达到了和上面储存地址范围相同的效果.</p><p>例如:</p><p><code>11001000 00010111 00010110 10100001</code>和第一个式子匹配度最高, 所以导向接口0.</p><p><code>11001000 00010111 00011000 10101010</code>和第二个式子匹配度最高(第三个式子没有000, 但是第二个式子有), 导向接口1.</p><h4 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h4><table><thead><tr><th>对比的方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信应当由网络来保证</td><td>可靠通信应当由用户主机来保证</td></tr><tr><td>网络层连接</td><td>提供主机到主机的连接服务</td><td>不提供主机到主机的连接服务</td></tr><tr><td>终端与网络</td><td>终端简单, 网络复杂</td><td>终端复杂, 网络简单</td></tr><tr><td>终点地址</td><td>仅在连接建立阶段使用, 每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组的转发</td><td>属于同一条虚电路的分组均按照同一路由进行转发</td><td>每个分组独立选择路由进行转发</td></tr><tr><td>当结点出故障时</td><td>所有通过出故障的结点的虚电路均不能工作</td><td>出故障的结点可能会丢失分组, 一些路由可能会发生变化</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点时不一定按发送顺序</td></tr><tr><td>端到端的差错处理和流量控制</td><td>可以由网络负责, 也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>其实之前说的网络层实现的功能, 转发与路径选择, 也是路由器实现的, 换句话说网络层的核心硬件其实就是路由器. 路由器实现了选路算法, 并将数据报转发到另一个路由器上.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/router.jpg" style="zoom:50%"><p>路由器由四部分组成:</p><ul><li><strong>输入端口</strong>: 物理层, 链路层的接入功能及查找功能, 以”线速”完成输入端口处理</li><li><strong>交换结构</strong>: 完成输入端与输出端的交换</li><li><strong>输出端口</strong>: 执行与输入端口完全相反的流程.</li><li><strong>选路处理器</strong>: 执行选路协议.</li></ul><p>在输入端口, 如果数据报到达的速度比交换结构转发速率快, 就需要排队. 同理, 在输出端口, 如果交换结构的数据报到达速度比数据报发送的速率更快时, 也要发生排队. 当队列满时, 就会发生溢出, 无论是在输入还是输出端口都有可能发生溢出. 排队时就会产生时延.</p><p><strong>线头(HOL)阻塞</strong>: 排队的数据报在队列的前面阻碍队列中的其他数据报转发.</p><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>互联网服务被定义成不可靠的, 尽力而为, 无连接分组交付系统.</p><ul><li>服务是<strong>不可靠</strong>的, 因为分组可能丢失, 重复, 延迟或不按序交付等, 但服务不检测这些情况, 也不提醒发送方和接收方.</li><li>服务是<strong>尽力而为</strong>的, 互联网并不随意地丢弃分组, 只有当资源用完或底层网络出现故障时才可能出现不可靠性.</li><li>服务是<strong>无连接</strong>的, 因为每个分组都是独立对待的. 分组序列可能经过不同的传输路径或者有的丢失有的到达.</li></ul><h4 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h4><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/ip数据报.jpg" style="zoom:50%"><p>在加上IP的头之后, TCP的开销就显得非常大了. IP一共是32bit*5/8=20bytes, 加上TCP报文段的20B信息一共是40B.</p><p>其中的寿命(Time to live, TTL)为<strong>0</strong>时数据报结束传输.</p><p>网络链路有MTU (Maximum Transmission Unit, 最大传输单元) – 最大可能的链路级帧, 大的IP数据报会被拆成很多个小段分别发送, 并在最终的目的地进行整合.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/ip分片.jpg" style="zoom:50%"><p>分片后头部信息的长度, ID, 偏移量, 段标识需要进行改变. 同一组分片的ID都是相同的, 偏移量总是依次向上加$\frac{MTU-20}{8}$. 每组最后一个片的段标识为0. 长度指的是包含IP头部所有的长度. 最终分片出来的个数应该是$\lceil \frac{\rm datagram-20}{\rm MTU-20}\rceil$片.</p><p>假设有4000B数据报, MTU为1500B.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/ip分片例子.jpg" style="zoom:50%"><p>因为分片前的数据报ID为X, 所以分片后也都是X. 一共分了$\lceil \frac{4000-20}{1500-20}\rceil=3$片, 前两片的长度都是MTU, 段标识都是1. 偏移量依次向上增加$\frac{1500-20}{8}=185$. 最后一片因为不是正好凑齐, 所以长度为$(4000-20) - (1500-20)\times 2+20=1040$, 段标识为0代表是分片的末尾.</p><p>再举个例子:</p><blockquote><p>datagram: 3000B</p><p>MTU: 500</p><p>ID: 422</p></blockquote><p>应该一共有$\lceil \frac{3000-20}{500-20}\rceil=7$片, 所有ID均为422, 偏移量依次向上增加$\frac{500-20}{8}=60$. 前6片的长度为500, 段标识为1. 最后一片的段标识为0, 长度为$(3000-20)-(500-20)\times6+20=120$.</p><h4 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h4><p>IP地址是对主机, 路由器接口的32-bit 标识符. 一般情况下, 路由器通常具有多个接口, 主机可能具有多个接口, IP编址与每个接口相联系. 在早期, 32位的IP地址被严格划分为8位一段, 即主机号和子网号必须严格是8的倍数. 子网号是高位地址, 主机号是低位地址. 直到有了CIDR协议, 打破了这种限制.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/五类地址.jpg" style="zoom:67%"><p>当然有一些关键的IP地址是要保留的, 因为他们很重要, 不能被占用.</p><p>主机号全为0的地址表示网络本身.</p><p>主机号全为1的保留作为定向广播, 是子网内的广播地址.</p><p><code>127.xxx.xxx.xxx</code>的任意IP保留作为环路测试TCP/IP以及本机进程之间的通信, 它不是一个网络地址. 如果还不理解, 它就是我们常见的<strong>localhost</strong>.</p><p>子网掩码也是一个32位的地址, 它将所有子网位置1, 主机位置0.</p><h5 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h5><p>子网: 具有IP地址相同的子网部分的设备接口, 能够物理上互相到达而没有中间路由器的网络叫做子网.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/子网.jpg" style="zoom:50%"><p>图中有三个子网, 三个子网通过一个路由器相连接. 与子网之外的主机互相通信必须借助路由器.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/子网2.jpg" style="zoom:50%"><p>图中除去最上方, 最下方一共三个子网外, 由于路由器和路由器不同接口的通信也满足子网定义, 所以一共有六个子网.</p><h5 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h5><p>CIDR(Classless InterDomain Routing, 无类型域间选路): 子网部分长度可以为任意位, 地址格式修改为<code>a.b.c.d/x</code>, 其中x为子网部分的长度.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/cidr.jpg" style="zoom:50%"><h5 id="IP地址计算"><a href="#IP地址计算" class="headerlink" title="IP地址计算"></a>IP地址计算</h5><blockquote><p>假设有一个已知的IP地址204.110.113.86/22, 请分别计算:</p><ol><li>子网掩码</li><li>网络本身地址</li><li>广播地址</li><li>网络中主机号的数量</li><li>IP地址范围</li></ol></blockquote><p>要计算出上述问题, 我们只关心主机和子网的一部分, 所以我们没必要将其全部化为二进制形式, 只需要将所需的段化为二进制即可.</p><ol><li>子网掩码: <code>255.255.252.0</code></li><li>网络本身地址: <code>204.110.112.0</code></li><li>广播地址: <code>204.110.115.255</code></li><li>网络中主机号的数量: $1022$</li><li>IP地址范围: <code>204.110.112.0 ~ 204.110.115.254</code></li></ol><p>一共有22位子网号, 所以所有分割一定以第三段IP的二进制为基础. 113是$64+32+16+1$, 转为二进制为<code>01110001</code>. 前6位被子网号所占, 后2位被主机号所占.</p><p>子网掩码将子网号全置1, 所以是<code>255.255.255-2-1.0</code>, 即<code>255.255.252.0</code>.</p><p>将<code>01110001</code>后两位置0, 即<code>01110000</code>, 也就是$113-1=112$, 故网络本身地址为<code>204.110.112.0</code>.</p><p>广播地址同理, 后两位置1, 即<code>01110011</code>, $112+2+1=115$, 广播地址为<code>204.110.112.255</code>.</p><p>因为网络主机号有$32-22=10$位, 除去网络本身和广播地址保留, 一共主机有$2^{10}-2=1022$个.</p><p>IP地址范围沿着上面写, 就是去除掉广播地址和网络本身的所有IP地址, 即<code>204.110.112.0 ~ 204.110.115.254</code>.</p><p>再来一个例子:</p><blockquote><p>假设有一个已知的IP地址190.168.100.5/20, 请分别计算:</p><ol><li>子网掩码</li><li>网络本身地址</li><li>广播地址</li><li>网络中主机号的数量</li><li>IP地址范围</li></ol></blockquote><p>还是与上面一样, 直接放答案:</p><ol><li>子网掩码: <code>255.255.240.0</code></li><li>网络本身地址: <code>190.168.96.0</code></li><li>广播地址: <code>190.168.111.0</code></li><li>网络中主机号的数量: $4094$</li><li>IP地址范围: <code>190.168.96.1 ~ 190.168.111.254</code></li></ol><h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>动态主机配置协议(Dynamic Host Configuration Protocol, DHCP) 常用于给主机<strong>动态</strong>地分配IP 地址, 它提供了<strong>即插即用</strong>联网的机制, 这种机制允许一台计算机加入新的网络和获取IP 地址而不用手工参与. DHCP 是应用层协议, 它是基于UDP 的.<br>DHCP 的工作原理如下:</p><p>使用客户／服务器方式. 需要IP 地址的主机在启动时就向DHCP 服务器广播发送发现报文, 这时该主机就成为DHCP 客户. 本地网络上所有主机都能收到此广播报文, 但只有DHCP 服务器(静态IP)才回答此广播报文. DHCP 服务器先在其数据库中查找该计算机的配置信息. 若找到, 则返回找到的信息. 若找不到, 则从服务器的IP 地址池中取一个地址分配给该计算机. DHCP 服务器的回答报文称为提供报文.</p><p>DHCP 服务器聚合DHCP 客户端的交换过程如下:</p><ol><li>DHCP 客户机广播”<strong>DHCP 发现</strong>“消息, 试图找到网络中的DHCP 服务器, 以便从DHCP服务器获得一个IP 地址.</li><li>DHCP 服务器收到”DHCP 发现消息后, 向网络中单播”<strong>DHCP 提供</strong>“消息, 其中包括提供DHCP客户机的IP 地址和相关配置信息.</li><li>DHCP 客户机收到”DHCP 提供”消息, 如果确认接收DHCP 服务器所提供的相关参数, 那么通过广播”<strong>DHCP 请求</strong>“消息向DHCP 服务器请求提供IP 地址.</li><li>DHCP 服务器收到”DHCP 请求”消息后, 单播一个”<strong>DHCP响应</strong>“.</li></ol><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/dhcp.jpg" style="zoom:67%"><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>NAT(Network Address Translation, 网络地址转换): 因为外部关注本地网络只使用的一个IP地址, 所以对于某个局域网下的设备完全可以对外共用一个IP地址. 通俗的说就是将网络划分为了<strong>公网</strong>和<strong>私网</strong>, 当多台私网内设备访问外部时, 都是通过一个中心设备做一次IP地址映射, 以同一个公网IP访问外部.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/nat.jpg" style="zoom:50%"><p>当私网内的IP发生变化时, 根本不用通知外网, 并且增强了私网设备的安全性, 大大的节省了IPv4数量.</p><h4 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h4><p>为了提高IP 数据报交付成功的机会, 在网络层使用了网际控制报文协议(Internet Control Message Protocol, ICMP) 来让主机或路由器<strong>报告差错和异常</strong>情况. ICMP 报文作为<strong>网络层</strong>数据报的数据, 加上数据报的首部, 组成IP 数据报发送出去. ICMP 是IP 层协议. ICMP 报文的种类有两种, 即ICMP 差错报告报文和ICMP 询问报文. ICMP 差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况.</p><ol><li>终点不可达. 当路由器或主机不能交付数据报时, 就向源点发送终点不可达报文.</li><li>源点抑制. 当路由器或主机由于拥塞而丢弃数据报时, 就向源点发送源点抑制报文, 使源点知道应当把数据报的发送速率放慢.</li><li>时间超过. 当路由器收到生存时间(TTL) 为零的数据报时, 除丢弃该数据报外, 还要向源点发送时间超过报文. 当终点在预先规定的时间内不能收到一个数据报的全部数据报片时, 就把已收到的数据报片都丢弃, 并向源点发送时间超过报文.</li><li>参数问题. 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时, 就丢弃该数据报, 并向源点发送参数问题报文.</li><li>改变路由(重定向) . 路由器把改变路由报文发送给主机, 让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由) .</li></ol><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>IPv6开始是为解决32位IPv4地址很快分配完而诞生的. 稍作了解即可.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/ipv6.jpg" style="zoom:50%"><ul><li>128位的IP地址</li><li><strong>固定</strong>长度 40 字节首部</li><li><strong>只能在源与目的上进行分片与重组装</strong></li><li>没有检查和</li><li>选项部分被移到首部之外</li></ul><p>IPv6和IPv4目前只能通过<strong>隧道</strong>的方式混用, 也就是在IPv路由器之间IPv6数据报作为IPv4数据报的负载.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/隧道.jpg" style="zoom:67%"><p>所谓的双栈不是一个很好的解决方法, 在一台设备上同时启用IPv4协议栈和IPv6协议栈, 同时分别配置了IPv4地址和IPv6地址, 对于IP地址耗尽的问题却没有任何帮助, 反而增加了网络的复杂度.</p><h3 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h3><p>选路是为了决定从源到目的地通过网络的”好的路径”, 选路问题可以抽象成图论问题.</p><p>全局的或分散的信息?</p><p>分散的:</p><ul><li>路由器知道物理相连的邻居, 到邻居的链路费用</li><li>计算的迭代过程, 与邻居交换信息</li><li>“距离矢量(DV)” 算法</li></ul><p>全局的:</p><ul><li>所有路由器具有完全的拓扑, 链路费用信息</li><li>“链路状态(LS)”算法</li></ul><p>静态的或动态的?</p><p>静态(非自适应): 路由随时间缓慢变化</p><p>动态(自适应): 路由更快地变化, 周期的更新, 适应链路费用变化</p><h4 id="Link-State-Routing-Algorithm"><a href="#Link-State-Routing-Algorithm" class="headerlink" title="Link State Routing Algorithm"></a>Link State Routing Algorithm</h4><p>LS采用的图论算法是<strong>Dijkstra</strong>算法, 所有节点知道网络拓扑, 链路费用, 经”链路状态广播”完成, 所有节点具有相同信息, 因此LS是<strong>全局</strong>的算法. 然后利用Dijkstra算法迭代得到最短路径.</p><p>$c(x,y)$: 从节点$x$到$y$的链路费用, 如果不是直接邻居则为$\infty$.</p><p>$D(v)$: 从源到目的地$v$路径的代价.</p><p>$p(v)$: 从源到$v$沿路径的前驱节点.</p><p>$N’$: 已知最小代价的节点集合.</p><blockquote><p>1 初始化:<br>2 N’ = {u}<br>3 对所有节点v<br>4 if v 临近 u<br>5 then D(v) = c(u,v)<br>6 else D(v) = ∞<br>7<br>8 Loop<br>9 找出w不在N‘中使得D(w)最小<br>10 将w加入N’<br>11 对于所有v临近w并不在N’中, 更新D(v):<br>12 D(v) = min( D(v), D(w) + c(w,v) )<br>13 /<em> 到v的新费用或是到v的老费用或到w加上从w到v的已知最短路费用</em>/<br>15 until 所有节点在 N‘中</p></blockquote><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/ls.jpg" style="zoom:67%"><blockquote><p>本题从u出发, 步骤0初始化先写好所有与u节点相邻的节点距离, 选择一个最小的, 即节点x, 加入已知集合N’.</p><p>步骤1对距离进行更新, 选择节点y(此处选择v会有不同的顺序, 但会有相同的结果)加入已知集合. 反复迭代, 最后得到结果.</p></blockquote><h4 id="Distance-Vector-Algorithm"><a href="#Distance-Vector-Algorithm" class="headerlink" title="Distance Vector Algorithm"></a>Distance Vector Algorithm</h4><p>DV算法是一个<strong>分布式</strong>的, <strong>可迭代</strong>的<strong>异步动态</strong>算法. 它采用的是<strong>贝尔曼 - 福特方程</strong>(动态规划里的一种解法). 每个路由器将自身的路由信息发送给邻居, 每个路由器将邻居发送来的信息更新自己的路由表, 若路由表更新则发送信息更新信息给邻居, 否则不发送. 但距离向量算法具有路由自环的缺点, 会导致好消息传的快, 坏消息传的慢的现象, 且可能会导致无穷计算的问题. 发生这种情况的话, 可以采用<strong>毒性逆转</strong>, 即当一条路径信息变为无效之后, 路由器并不立即将它从路由表中删除, 而是用不可达的度量值将它广播出去.</p><p>$d_x(y)$: x到y的最低费用.</p><p>$c(x, v)$: 节点x到邻居v的代价.</p><p>$D_x$: 节点x到其他所有节点距离的向量, $D_x=[d_x(y): y\in N]$.</p><p>$S_x$: 节点x到其他所有节点后继的向量, $S_x=[s_x(y): y\in N]$. $s_x(y)$为节点x到y的后继节点.</p><p>当节点x接收到来自邻居的新距离向量估计, 它使用B-F方程更新其自己的距离向量:<br>$$<br>D_x(y) \leftarrow \min_v\{c(x, y)+D_v(y): y\in N\}<br>$$<br><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/dv.jpg" style="zoom:67%"></p><p>在节点u计算完到达其他所有节点的$d_u(x)$后, 产生一个距离向量$D_u$, 和一个后继向量$S_u$.</p><p>因此, 每个节点要做的只是<strong>等待通知 -&gt; 重新计算 -&gt; 通知邻居</strong>的循环. 所以说它是一个能够自适应的分布式动态异步算法.</p><h4 id="LS和DV的对比"><a href="#LS和DV的对比" class="headerlink" title="LS和DV的对比"></a>LS和DV的对比</h4><table><thead><tr><th></th><th>LS 算法</th><th>DV 算法</th></tr></thead><tbody><tr><td>原理</td><td>使用全局信息的算法, 网络拓扑和所有的链路费用是已知的, 通过让每个节点向网络中的所有其它路由器广播链路状态分组来完成.</td><td>每个节点的选路表包括了它的距离向量和它的每个邻居的距离向量, 并不时地向它的每个邻居发送它的距离向量拷贝.</td></tr><tr><td>算法</td><td>Dijkstra算法, 是迭代算法</td><td>是一种迭代的, 异步的和分布式的算法</td></tr><tr><td>计算方法</td><td>计算从源节点到网络中所有其它节点的最低费用路径 经算法迭的第K次迭代后, 可知道到K个目的节点的最低费用.</td><td>从邻居接收更新距离向量, 重新计算选路表项和通知邻居到目的地的最低费用路径的费用已经变化的过程继续下去, 直到无更新报文发送为止.</td></tr><tr><td>特性</td><td>报文复杂, 收敛速度快</td><td>报文少, 收敛速度慢</td></tr></tbody></table><h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><p>由于网络规模增大到一定程度时候, 路由表不可能存放下所有的信息. 将某区域的路由器聚合成为 “自治系统” (AS), 在相同AS中的路由器运行相同的选路协议, 在不同AS中可以不用运行相同的选路协议. 连接AS间的路由器称为<strong>网关</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/等级选路.jpg" style="zoom:67%"><p>假设AS1要将接收到的数据报转发到外部, 此时网关不唯一, 那么AS1必须要知道AS2能到达哪些目的地, AS3能到达哪些目的地, 还必须将这些信息传播到AS1内部的所有路由器. 这些内容都由<strong>AS之间的选路协议</strong>负责. 层次路由应运而生, 如何管理跨越AS之间的路由情况, 就是AS间选路协议要解决的问题.</p><p>在AS1中选择网关时, 是由AS间路由协议完成, 采用<strong>热土豆路由</strong>, 也就是直接发送给离自己最近的网关即可.</p><h3 id="互联网中的选路"><a href="#互联网中的选路" class="headerlink" title="互联网中的选路"></a>互联网中的选路</h3><p>RIP和OSPF都属于IGP(Interior Gateway Protocol, 内部网关协议), 即AS内的协议, 而BGP属于EGP(Exterior Gateway Protocol, 外部网关协议), 也就是AS间的协议.</p><h4 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h4><ul><li>是最早的<strong>AS内部</strong>因特网选路协议, 是一种<strong>距离向量</strong>协议.</li><li>使用跳数(hop) 做为其费用测度, 一条路径的最大费用被限制为<strong>15</strong>(防止无穷计算).</li><li>RIP中, 选路信息在<strong>邻居之间</strong>通过RIP响应报文交换, 约<strong>30</strong>秒交换一次.</li><li>每台路由器维护一张RIP表, 称为选路表, 包括该路由器的距离向量和该路由器的转发表.<ul><li>选路表的更新</li></ul></li><li>RIP使用IP协议之上的UDP协议来实现网络层功能, 该UDP报文段在标准IP数据报中承载在路由器之间.</li><li>RIP被设置在较低层ISP和企业网中.</li><li>RIP协议通过应用层进程进行管理, 周期性通过UDP数据报发送.</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/rip.jpg" style="zoom:67%"><h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><p>OSPF(Open Shortest Path First)是开放最短路径优先算法, 开放指协议是公开发表, 公众可用的, 最短路径优先指的是使用了Dijkstra提出的最短路径算法(采用LS分组扩散). 也是一个作用域<strong>AS内部</strong>的算法.</p><ul><li>OSPF通常被设置在较顶层的ISP中.</li><li>它的核心是一个使用<strong>洪泛</strong>链路状态信息的链路状态协议和一个Dijkstra 最低费用路径算法.</li><li>一台路由器构建了一幅关于整个AS的<strong>完整拓扑图</strong>.</li><li>使用OSPF时, 路由向自治系统内所有其它路由器广播选路信息. OSPF报文直接封装在<strong>IP数据报</strong>中, 必须实现可靠传输.</li><li>仅当链路状态发生变化时, 路由器才向所有路由器洪泛发送信息.</li></ul><p><strong>OSPF优点</strong>:</p><ul><li>安全: 交换都是经过鉴别的</li><li>多条费用相同的路径: 费用相同时, 可以使用多条(负载均衡, RIP中只能用一条)</li><li>对单播选路与多播选路的综合支持</li><li>支持在单个选路域内的层次结构</li><li>AS内的一个OSPF区域配置成主干区域, 区域间选路要求分组首先路由到一个区域边界路由器, 再通过主干路由器到目的区域的区域边界路由器, 最后到达目的.</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/层次ospf.jpg" style="zoom:50%"><p>有<strong>局部</strong>(Area)和<strong>主干</strong>(Backbone)两级分层, 链路的状态通告仅在区内, 每个节点具有详细的区域拓扑, 仅知道到其他区域网络的方向(最短路径). 区边界路由器(Area border routers)汇总了到在自己区域网络的距离, 向其他区域边界路由器通告. 主干路由器(Backbone Routers)在主干区运行OSPF算法, 边界路由器(Boundary routers)要连接其他的AS.</p><h4 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h4><p>边界网关协议(Border Gateway Protocol, BGP) 是不同自治系统的路由器之间交换路由信息的协议, 是一种外部网关协议. 边界网关协议常用于互联网的网关之间. 路由表包含已知路由器的列表, 路由器能够达到的地址及到达每个路由器的路径的跳数. 内部网关协议主要设法使数据报在一个AS 中尽可能有效地从源站传送到目的站. 在一个AS内部不需要考虑其他方面的策略. 然而BGP 使用的环境却不同, 主要原因如下:</p><ol><li>因特网的规模太大, 使得自治系统之间路由选择非常困难.</li><li>对于自治系统之间的路由选择, 要寻找最佳路由是很不现实的.</li><li>自治系统之间的路由选择必须考虑有关策略.</li></ol><p>边界网关协议(BGP) 只能力求寻找一条能够到达目的网络且<strong>比较好的路由</strong>(不能兜圈子) , 而并非寻找一条最佳路由. BGP 采用的是<strong>路径向量</strong>路由选择协议, 它与距离向量协议和链路状态协议有很大的区别. BGP 的实现是<strong>应用层</strong>协议(BGP本身肯定是网络层协议), 基于<strong>TCP</strong> (AS间的策略比性能更加重要), 端口号179. 支持CIDR.<br>BGP 的工作原理如下: 每个AS的管理员要选择至少一个路由器(可以有多个) 作为该自治系统的”<strong>BGP 发言人</strong>“. 一个BGP 发言人与其他自治系统中的BGP 发言人要交换路由信息, 就要先建立TCP 连接(可见BGP 报文是通过TCP 传送的, 也就是说<strong>BGP 报文是TCP 报文的数据部分</strong>) , 然后在此连接上交换BGP 报文以建立BGP 会话, 再利用BGP 会话交换路由信息. 当所有BGP 发言人都相互交换网络可达性的信息后, 各BGP 发言人就可找出到达各个自治系统的较好路由. 每当可达性信息发生变化时, 才进行交换, 否则不交换.</p><ul><li><strong>eBGP</strong>: 跨越两个AS的BGP会话(外部)</li><li><strong>iBGP</strong>: 同一个AS中的两台路由器之间的BGP会话(内部)</li></ul><h3 id="广播和多播选路"><a href="#广播和多播选路" class="headerlink" title="广播和多播选路"></a>广播和多播选路</h3><p>广播和多播是什么?</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/广播和多播.jpg" style="zoom:50%"><p><strong>广播选路</strong>: 从一个源节点到网络中的所有其它节点交付分组.</p><p><strong>多播选路</strong>: 使单个源节点能够向其它网络节点的一个子集发送分组的拷贝.</p><p>当向多个接收方发送相同的数据时, 为了更好的带宽利用率, 较少的主机/路由器处理和更快的参与, 就需要多播.</p><h4 id="广播选路算法"><a href="#广播选路算法" class="headerlink" title="广播选路算法"></a>广播选路算法</h4><p><strong>无控制洪泛</strong>: 要求源节点向它的所有邻居发送该分组拷贝, 产生广播风暴.</p><p><strong>受控洪泛</strong>:</p><ul><li>序号控制洪泛: 加入控制序号, 重复时, 直接丢弃. 否则, 保存并广播.</li><li>反向路径转发RPF: 考虑是否为最短路径上转发的分组. 仅当该分组到达的链路正好是位于源节点到该节点的最短单播路径上, 它才向其所有出链路(除了它接收的那个) 传输报文. 否则, 丢弃入分组.</li></ul><p><strong>生成广播树</strong>: 避免环的产生, 因此可以完全避免冗余广播.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/生成广播树.jpg" style="zoom:67%"><p>这是一种基于中心的生成树构造过程:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/生成广播树2.jpg" style="zoom:67%"><p>定义一个中心节点, 其他节点都向中心节点进行单播, 并将路径加入这棵树, 如果路径的一部分已经在树中了, 那么取剩下未加入的部分加入到树中.</p><h4 id="多播选路算法"><a href="#多播选路算法" class="headerlink" title="多播选路算法"></a>多播选路算法</h4><p>在多播通信中, 面临两个问题, 即怎样标识多播分组的接收方, 以及怎样为发送到这些接收方的分组编址. 在因特网体系结构中, 多播数据报使用<strong>间接地址</strong>来编址. 表示一组接收方的单一标识就是一个 D 类多播地址. 与一个 D 类地址相关联的多个接收方称为一个多播组.</p><p><strong>IGMP</strong>(Internet Group Management Protocol, 互联网组管理协议) 运行在一台主机与其直接相连的路由器之间. IGMP 为一台主机提供了手段, 可让它通知与其相连的路由器, 在本主机上运行的一个应用程序如何加入一个特定的多播组.</p><p>在实践中有两种方法用于确定多播选路树:</p><p><strong>使用一棵组共享树进行多播选路</strong>. 像在生成树广播的场合中一样, 跨越组的共享树多播选路基于一棵多播树, 该树包括所有具有属干该多播组的相连主机的边缘路由器. 在使用基于中心方法来构造多播选路树, 具有属于多播组相连主机的边缘路由器向中心节点(经单播)发送加入消息. 像在广播情况下一样, 一个加入报文使用单播选路朝着中心转发, 直到它到达已经属干多播树的一台路由器或到达这个中心.</p><p><strong>使用一棵基于源的树进行多播选路</strong>. 为多播组中的每个源构建一棵多播选路树. 在实践中, 使用 RPF 算法来构造一棵多播转发树, 以用于转发来自源节点的多播数据报.</p><p>第一个用于因特网中的多播选路协议是<strong>距离向量多播选路协议</strong>(Distance Vector Multicast Routing Protocol, <strong>DVMRP</strong>).</p><ul><li>洪泛与剪枝: 反向路径转发, 基于源的树</li><li>基于DVMRP自己的选路表的RPF 树, 通过DVMRP路由器的通信构造</li><li>向多播组发起的数据报经RPF洪泛到各处</li><li>无组成员的路由器: 发送上游剪枝报文</li></ul><h2 id="链路层和局域网"><a href="#链路层和局域网" class="headerlink" title="链路层和局域网"></a>链路层和局域网</h2><p>因为网络层考虑的是解决路径选择和转发的问题, 链路层更加的贴近于物理层, 解决的是<strong>同一链路</strong>主机的数据如何在连路上进行传输的问题. 比如说解决在链路传播比特级的差错和纠错, 半双工全双工, 链路上的流量控制, 链路冲突问题等. 链路层把网络层传下来的分组封装成<strong>帧</strong>(frame). 不同的链路完全可以提供<strong>不同的链路协议</strong>而不互相干扰, 在链路上的传输控制免不了物理设备的配合, 即<strong>网卡</strong>(NIC).</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/链路层.jpg" style="zoom:80%"><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>EDC(Error Detection and Correction bits), 实际上差错检测是<strong>差错的检测和纠错</strong>. 差错检测可能保护各层的头信息. 但是差错检测也不是完全可靠, 因为协议可能会漏掉某些差错.</p><h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>奇偶校验比较简单, 能够检测出错误, 但是不能对错误进行纠正.</p><p><strong>奇校验</strong>: 添加冗余位使得整个序列中1的个数为奇数.</p><p><strong>偶校验</strong>: 添加冗余位使得整个序列中1的个数为偶数.</p><p>比如<code>0111000110101011|0</code>添加了一位冗余, 使得整个序列中1的个数为9, 即奇数, 所以这是奇校验. 添加一位冗余的奇偶校验只能检测出有1比特的错误, 也不能确定位置.</p><p>二维比特奇偶校验不但能检测出1比特差错, 还能将其纠正.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/二维奇偶校验.png" style="zoom:33%"><p>图中所示的是二维偶校验, 将原始序列按照行列排好, 每行每列都产生一位冗余位, 最后再按照同样奇偶规则将产生的冗余位再加一位校验冗余位. 最下面左侧的图是还没有发送前保存的数据, 右侧是接收方接收到的数据. 将冗余位进行比对, 由于第二行不满足1个数为偶数, 所以说第二行有错误. 第二列也不满足, 所以错误定位到第二行第二列. 这样就完成了错误差错检测.</p><h4 id="检查和-1"><a href="#检查和-1" class="headerlink" title="检查和"></a>检查和</h4><p>检查和就是之前传输层的检查和, 只能做到差错检测, 如果有错自己做其他处理.</p><h4 id="CRC循环冗余校验"><a href="#CRC循环冗余校验" class="headerlink" title="CRC循环冗余校验"></a>CRC循环冗余校验</h4><p>将数据比特$\rm D$视为一个二进制数, 选择$r$个CRC比特$\rm R$, 使得接收方通过某个生成多项式转换为$r+1$位二进制数$\rm G$能整除$\rm &lt;D, R&gt;$. 如果有非零余数即检测到差错.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/crc格式.jpg" style="zoom:67%"><p>$\rm R$就是我们最终要计算出来的东西. 在写出$\rm &lt;D,R&gt;$ 前, 需要根据多项式位数对数据$\rm D$进行移位, 多项式$\rm G$ 是$r+1$位, 就将数据$\rm D$ 后添加$r$ 个0(也就是下述式子所述的$\rm D\cdot 2^r$), 从而满足求出来的余数一定是$r$ 位.<br>$$<br>\rm R = 余数[\frac{D\cdot2^r}{G}]<br>$$<br>如何将生成多项式转化为二进制数? 其实就是取多项式系数的过程. 假设生成多项式为$x^5+x^4+x+1$, 那么对应的二进制数就是<code>110011</code>, 从$1\times x^5+1\times x^4+0\times x^3+0\times x^2+1\times x+1\times x^0$ 提取系数得来.</p><p>看一个例子:</p><blockquote><p>假设多项式为$\rm G(x)=x^3 + 1$, 数据$\rm D=101110$, 求CRC位$\rm R$.</p></blockquote><p>先将多项式转化为二进制, 即<code>1001</code>, 是4位, 则将D的右侧补3个0. 然后进行二进制除法. <strong>二进制除法的本质是异或(XOR)</strong>, 因为每一位除的结果不影响其他位, 加法不进位，减法不借位, 所以实际上就是异或.</p><p>只要遵循够$r+1$位商1, 否则商0的原则, 就能得到结果. 如下所示:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/crc.jpg" style="zoom:67%"><p>除到最后时, 如果不满足$r$ 位不要忘记<strong>添0</strong>.</p><p>再来一个例子检验一下:</p><blockquote><p>假设多项式为$\rm G(x)=x^3 + 1$, 数据$\rm D=100101110$, 求CRC位$\rm R$.</p></blockquote><p>结果为<code>11010</code>.</p><h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><p>对于链路, 往往有两种, 一种是点对点类型的, 还有一种市广播类型的. 多路访问协议能够一定程度上解决两个节点的并行传输问题, 也称为<strong>碰撞</strong>. 在这个过程中, 被共享的信道必须通过其自身解决, 不增加外来信道进行协调, 否则也失去了多路访问协议存在的意义.</p><p>在理想的多路访问协议中, 一个节点传输时, 应该达到信道的最大传输速率, 多个节点传输时应该达到平均最大传输速率. 并且没有其他的特殊节点协调, 也没有同步时钟和间隙.</p><p>MAC协议分为三大类:</p><ul><li>信道划分: 将信道划分为较小的“段” (时隙，频率，编码), 为节点分配一部分专用.</li><li>随机访问: 不划分信道，<strong>允许碰撞</strong>, 但想方设法从“碰撞”恢复.</li><li>轮转: 节点轮转，但有更多信息要发送的能够轮转的较长时间.</li></ul><h4 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h4><p>信道划分实际上有四个算法, 分别是时分多路访问TDMA, 频分多路访问FDMA, 波分多路复用WDM, 码分多路访问CDMA.</p><h5 id="TDMA"><a href="#TDMA" class="headerlink" title="TDMA"></a>TDMA</h5><p>TDMA(Time division multiple access, 时分多路访问):</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/tdma.jpg" style="zoom:67%"><p>每个站点在每个循环中获得<strong>固定长度时隙</strong>, 循环访问信道, 不占用空闲的时隙. 上图中时隙2, 5, 6空闲.</p><h5 id="FDMA"><a href="#FDMA" class="headerlink" title="FDMA"></a>FDMA</h5><p>FDMA(Frequency division multiple access, 频分多路访问):</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/fdma.jpg" style="zoom:67%"><p>为信道频谱划分为多个频带, 每个站点分配固定的频带, 每个频带上分别传输, 也不占用空闲的频带. 上图中频带2, 5, 6空闲.</p><h5 id="CDMA"><a href="#CDMA" class="headerlink" title="CDMA"></a>CDMA</h5><p>CDMA(Code Division Multiple Access, 码分多路访问):</p><p>码分多路访问下, 所有用户共享相同的频道, 也共享相同的时间. 每个比特时间被划分为m个更短的时间槽, 称为”<strong>码片</strong>“. 每个用户用自己的”码片序列”对数据进行编码, 在输出端进行解码, 这些序列应该是相互”正交”的, 所以不会相互干扰. 在<strong>WIFI</strong>经常用到这种技术.</p><h5 id="WDM"><a href="#WDM" class="headerlink" title="WDM"></a>WDM</h5><p>WDM(Wavelength Division Multiplexing, 波分多路复用):</p><p>波分多路复用就是光的频分多路复用，在一根光纤中传输多种不同波长(频率) 的光信号，由于波长(频率) 不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/wdm.png" style="zoom:50%"><h4 id="随机访问协议"><a href="#随机访问协议" class="headerlink" title="随机访问协议"></a>随机访问协议</h4><h5 id="时隙ALOHA"><a href="#时隙ALOHA" class="headerlink" title="时隙ALOHA"></a>时隙ALOHA</h5><p>一句话概括: <strong>时隙 + 概率重传</strong>.</p><p><strong>假定</strong>:</p><ul><li>所有帧有相同长度</li><li>时间划分为等长时隙，能够传输1个帧</li><li>节点是同步的, 且节点仅在时隙开始时开始传输帧</li><li>如果2个或多个节点在时隙中传输，所有节点检测碰撞</li></ul><p><strong>操作</strong>:</p><ul><li>当节点获得新帧，将在下一个时隙中传输</li><li>无碰撞，节点能够在下一个时隙中发送新帧</li><li>如果碰撞，节点在每个后继时隙中以<strong>概率p重传帧</strong>直到成功</li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/时隙aloha.jpg" style="zoom:67%"><p>这么搞看起来是没啥问题, 但是实际上时隙空闲的概率非常高.</p><p>假定$N$个有许多帧要发送节点，每个时隙以概率$p$发送.</p><p>某个节点在一个时隙中成功发送的概率为$p(1-p)^{N-1}$, 即除自己外的其他节点都重传失败. 那么任何节点成功发送的概率为$Np(1-p)^{N-1}$.</p><p>下面来求一下这个概率的最大值$p_{max}$,<br>$$<br>\begin{aligned}<br>E(p)&amp;=Np(1-p)^{N-1} \\<br>E’(p)&amp;=N(1-p)^{N-1} -Np(1-p)^{N-2} \\<br>&amp;=N(1-p)^{N-2}((1-p)-p(N-1))\\<br>E’(p)&amp;=0 \Rightarrow p_{max}=\frac{1}{N}<br>\end{aligned}<br>$$</p><p>当有无穷多个节点, 即$N\rightarrow \infty$时,<br>$$<br>\displaylines{<br>\lim_{N\to\infty}E(p_{max})=N\frac{1}{N}(1-\frac{1}{N})^{N-1} = \frac{(1-\frac{1}{N})^N}{1-\frac{1}{N}} \\<br>\lim_{N\to \infty}{1-\frac{1}{N}}=1 \qquad\lim_{N\to \infty}({1-\frac{1}{N}})^N=\frac{1}{e} \\<br>\lim_{N\to \infty}{E(p_{max})}=\frac{1}{e}=37\%<br>}<br>$$<br>即在节点无穷多时, 效率最终只有$37\%$.</p><p><strong>优点</strong>:</p><ul><li>单个活跃节点能够连续地以信道的全速传输</li><li>仅节点中的时隙需要同步, 即高速分散</li><li>简单</li></ul><p><strong>缺点</strong>:</p><ul><li>碰撞后可能浪费时隙</li><li>空闲时隙无法利用</li><li>节点可能能够以小于传输分组的时间检测到碰撞</li><li>所有节点时钟同步</li></ul><h5 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h5><p>一句话概括: <strong>想发就发 + 随机重传</strong>.</p><p>也就是非时隙的ALOHA, 更简单, 没有同步的要求. 当帧到达时立即进行传输. 增加了碰撞的概率. 如果接收方在一定时间内没有收到, 那就判断发生了冲突.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/非时隙aloha.jpg" style="zoom:67%"><p>从效率角度考虑一下呢? 仍然采用帧传输时间为时间单元. 在任意给定时间, 某节点传输一个帧的概率为$p$. 假设该帧在$t_0$ 时刻开始传输, 为了使得这帧传输成功, 则在$[t_0-1, t_0]$不能有其他节点进行传输. 所有其他节点在这个时间间隔不开始传输的概率是$(1-p)^{N-1}$, 同样在$t_0$时刻也不能有其他节点进行传输, 概率也是$(1-p)^{N-1}$. 所以对于$t_0$时刻一个节点传输成功的概率是$(1-p)^{2(N-1)}$.</p><p>仍然先求出发送成功概率的最大值$p_{max}$.<br>$$<br>\begin{aligned}<br>E(p)&amp;=Np(1-p)^{2(N-1)} \\<br>E’(p)&amp;=N(1-p)^{2(N-1)} -Np2(N-1)(1-p)^{2(N-2)} \\<br>&amp;=N(1-p)^{2N-3}((1-p)-p2(N-1))\\<br>E’(p)&amp;=0 \Rightarrow p_{max}=\frac{1}{2N-1}<br>\end{aligned}<br>$$<br>然后再求出当节点区域无穷时的极限.<br>$$<br>\displaylines{<br>\lim_{N\to\infty}E(p_{max})=\frac{N}{2N-1}(1-\frac{1}{2N-1})^{2(N-1)} \\<br>\lim_{N\to \infty}{\frac{N}{2N-1}}=\frac{1}{2} \qquad\lim_{N\to \infty}({1-\frac{1}{2N-1}})^{2N-1}=\frac{1}{e} \\<br>\lim_{N\to \infty}{E(p_{max})}=\frac{1}{2} \cdot \frac{1}{e} = 18\%}<br>$$<br>实际上纯ALOHA的效率还不如时隙ALOHA, 也就是时隙ALOHA的一半.</p><h5 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h5><p>CSMA(Carrier Sense Multiple Access, 载波侦听多路访问). 前面的信道划分协议都是不管别人有没有在传输, 都会直接传输试试, 再判断是否有人传输, 这从逻辑上就有点反常. 在别人已经进行传输时, 自己再进行传输, 岂不是白费功夫? 别人在说话时候你打岔, 就大大增加了冲突的概率. CSMA就是一个在<strong>传输前侦听</strong>的访问协议. 如果侦听到信道正忙, 则推迟传输. 先听听有没有人在说话, 如果有就等别人说完了再说. 碰撞仍然会出现, 但是概率会减小.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/csma.jpg" style="zoom:67%"><p>但是考虑到传播时延, 也许节点已在传播数据, 但还在路上, 有些节点可能还没有检测到信道忙信号. 这当然会有一些问题, 叫最小帧长问题, 后面会说.</p><p>CSMA实际上有三种:</p><ul><li><strong>1-坚持 CSMA:</strong> 节点发送数据时先侦听信道是否空闲, 如果空闲则立即发送, 如果忙就一直侦听, 等到空闲时再发送. 发生冲突时, 随机等待一段时间后再重新侦听. “1-坚持”指的是信道忙时继续坚持侦听信道, 信道空闲时发送的概率为1, 立刻发送数据.</li><li><strong>非坚持 CSMA</strong>: 节点发送数据时先侦听信道是否空闲, 如果空闲则立即发送, 如果忙就放弃侦听, 等待随机一段时间后再侦听, 发送, 重复上述过程.</li><li><strong>p-坚持 CSMA</strong>: 用于时分信道, 发送数据前先侦听信道, 如果信道忙就继续侦听, 直到信道空闲. 如果信道空闲, 有概率p发送数据, 有概率1-p推迟到下个时隙. 如果下个时隙信道仍然空闲, 仍然重复上述过程, 直到信道忙为止. 如果信道忙则等到下个时隙再重新开始侦听.</li></ul><h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><p>CSMA/CD(Carrier Sense Multiple Access with Collision Detection, 载波监听多点接入/碰撞检测):</p><ul><li>CS: <strong>载波监听/侦听</strong>，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据中</strong>都要检测一下总线上是否有其他计算机在发送数据。</li><li>MA: <strong>多点接入</strong>，说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</li><li>CD: <strong>碰撞检测(冲突检测) <em><em>, </em></em>边发送边监听</strong>，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。如果一个站发现了总线上出现了碰撞，其适配器就要<strong>立即停止</strong>发送，免得继续进行无效的发送，白白浪费网络资源，然后等待一段时间随机时间后再次发送, <strong>半双工网络</strong>.</li></ul><p>如果几个发生碰撞的站都在监听信道，那么都会同时发现信道变成了空闲，如果此时都同时发送，那么肯定在原来的地方又发生了碰撞，所以碰撞后使用<strong>二进制指数退避算法</strong>, 往往等待时间再发送.</p><blockquote><p>先听后发, 边听边发</p><p>冲突停发, 随机重发</p></blockquote><h5 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h5><p>A节点发了一个很短的帧, 但是发生了碰撞. 这个帧是在发送完毕的时候才检测到发生碰撞, 没法停止发送, 已经发完了. CSMA/CD希望能及时控制局面, 就必须有一个<strong>最小帧长</strong>来限制最短帧的发送, 最起码要在帧没发送完的时候检测到碰撞. 下面来探究一下这个问题.</p><p>假设A与B两个节点都需要传输数据, 单程传播时延为$\tau$. 在$t=0$时刻A开始发送数据, B检测到信道空闲. 在$t=\tau-\delta$ 时刻A的数据还没到达B, B检测到信道空闲而发送数据. 但发送数据$\delta/2$ 后, 即$t=\tau-\delta/2$ 时刻, A和B发生的数据发生碰撞, 但返回的信息还没到达A和B, 所以A和B都不知道. 在$t=\tau$时, B检测到碰撞, 于是停止发送数据. 在$t=2\tau-\delta$ 时刻, A检测到碰撞, 于是也停止发数据. 因此明显在CSMA/CD协议下只能进行半双工通信.</p><p>A在发送帧后最多经过$2\tau(\delta \to 0)$ 的时间就能知道发送的帧是否发生碰撞. 因此将这个$2\tau$ 叫做<strong>争用期(</strong>也称冲突窗口或碰撞窗口). 只有经过这段争用期后, 才能确定这次不会产生发送冲突.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/最小帧长.jpg" style="zoom:50%"><p>因此, 为确保发送站在发送数据的同时能检测到可能存在的冲突, 需要在<strong>发送完帧之前</strong>就能接收到自己发送出去的数据, 即<strong>帧的传输时延最少要两倍于信号在总线中的传播时延</strong>. 所以必须要有一个最小帧长来约束, 任何小于最小帧长的帧都是被打断的异常帧.<br>$$<br>最小帧长=总线传播时延\times数据传输率\times2<br>$$</p><blockquote><p>以太网规定取$51.2\mu s$为争用期的长度. 对于10Mb/s的以太网, 在争用期内可发送512bit, 即64B. 如果前64B未发生冲突, 那么剩下的后续数据肯定不会发生冲突(表示已经抢占信道). 因此因特网规定最小帧长为64B, 小于64B的都是冲突而终止的无效帧.</p><p>如果只发送小于64B的帧, 需要在MAC子层中于数据字段后面加入填充字段保证帧长不小于64B.</p></blockquote><h4 id="轮转协议"><a href="#轮转协议" class="headerlink" title="轮转协议"></a>轮转协议</h4><p>轮转协议兼顾了信道划分和随机访问的优点, 使用一个”令牌”进行传递, 使得大家轮流进行传输.</p><h5 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h5><ul><li><p>指定一个主节点，主节点轮询每个节点.</p></li><li><p>主节点依次通知每个节点它被允许的传输量，在该节点传输完毕后(传完最大传输量或无更多待传输数据) ，主节点再通知下一个节点.</p></li><li><p>引入了轮询时延，即主节点通知从节点的时延.</p></li><li><p>主节点故障会导致信道崩溃.</p></li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/轮询.jpg" style="zoom:67%"><h5 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h5><ul><li><p><strong>令牌</strong> 小特殊帧，以某种次序在所有节点间传播.</p></li><li><p>当节点收到令牌时，当且仅当它有数据要传输时，它才持有该令牌并传输一个最大限制内的数据而后将令牌传递给下一个节点. 否则，它立即向下一个节点传输令牌.</p></li><li><p>一个节点的故障(如不肯释放令牌) 可能导致信道崩溃.</p></li></ul><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/令牌.png" style="zoom:67%"><h3 id="链路层编址"><a href="#链路层编址" class="headerlink" title="链路层编址"></a>链路层编址</h3><p>虽然高层程序希望设备用IP地址进行通信, 但是传输起来的实际通信必须采用设备的物理地址.</p><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>MAC地址(Media Access Control Address)是<strong>48bit</strong>的<strong>物理地址</strong>. 用于使数据报从一个接口到达另一个物理连接的接口, 在网络设备出厂时MAC地址就已经烧入了设备, <strong>全球唯一</strong>.</p><p>广播地址: <code>FF-FF-FF-FF-FF-FF</code></p><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>ARP(Address Resolution Protocol, 地址解析协议) 完成了从局域网IP到MAC物理地址的映射. 每个主机, 路由器都有ARP表, 存放了<code>&lt;IP, MAC, TTL&gt;</code>, 是一张动态表.. TTL是地址映射能存活的时间, 一般是20分钟.</p><h5 id="相同网络的ARP协议"><a href="#相同网络的ARP协议" class="headerlink" title="相同网络的ARP协议"></a>相同网络的ARP协议</h5><p>在相同的局域网中, A要向B发送数据报, 但B的MAC地址不在A的ARP表中, 需要执行下述步骤:</p><p>在相同的局域网中, A要向B发送数据报, 但B的MAC地址不在A的ARP表中, 需要执行下述步骤:</p><ol><li>A通过<code>FF-FF-FF-FF-FF-FF</code>广播ARP查询分组, 包括了B的IP, 在局域网内的所有机器都收到了ARP请求.</li><li>B接收ARP分组, 用自身的MAC地址通过单播回答了A.</li><li>A在ARP表中缓存了B的IP到MAC地址映射, 直到TTL为0.</li></ol><p>上述ARP查询和ARP响应分组为:</p><table><thead><tr><th>ARP query packet</th><th>ARP response packet</th></tr></thead><tbody><tr><td>Sip: 137.196.7.78</td><td>Sip: 137.196.7.14</td></tr><tr><td>Dip: 137.196.7.14</td><td>Dip: 137.196.7.78</td></tr><tr><td>Smac: 1A-2F-BB-76-09-AD</td><td>Smac: 58-23-D7-FA-20-B0</td></tr><tr><td>Dmac: FF-FF-FF-FF-FF-FF</td><td>Dmac: 1A-2F-BB-76-09-AD</td></tr></tbody></table><h5 id="不同网络的ARP协议"><a href="#不同网络的ARP协议" class="headerlink" title="不同网络的ARP协议"></a>不同网络的ARP协议</h5><p>仍然是A给B发送数据报, 但这回A和B属于两个不同的网络. 假定A知道B的IP地址.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/arp不同局域网.jpg" style="zoom:80%"><p>在连接局域网LAN1和LAN2的路由器R中有两张ARP表, 每张表对应了一个局域网.</p><ol><li>A生成具有源A, 目的地B的数据报.</li><li>A使用ARP从<code>111.111.111.110</code>得到R的MAC地址 .</li><li>A生成以R的MAC地址作为目的地的链路层帧,帧包含A-to-B IP 数据报.</li><li>A的适配器发送帧, B的适配器接收帧.</li><li>R从以太网帧取出IP数据报，看到它目的地是B.</li><li>R使用ARP得到B的MAC地址.</li><li>R生成包含A-to-B IP数据报的帧向B发送.</li></ol><p>其分组如下:</p><table><thead><tr><th>Frame A to R</th><th>Frame R to B</th></tr></thead><tbody><tr><td>Sip: 111.111.111.111</td><td>Sip: 111.111.111.111</td></tr><tr><td>Dip: 222.222.222.222</td><td>Dip: 222.222.222.222</td></tr><tr><td>Smac: 74-29-9C-E8-FF-55</td><td>Smac: 1A-23-F9-CD-06-9B</td></tr><tr><td>Dmac: E6-E9-00-17-BB-4B</td><td>Dmac: 49-BD-D2-C7-56-2A</td></tr></tbody></table><p>可以这样理解, 网络层不牵扯到物理地址, 所以IP始终没发生变化. 但是实际上在下层传输的链路层用到了物理地址, IP和MAC的地址映射工作完全交给<strong>中间人</strong>路由器完成了.</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>以太网是全球使用最广泛的局域网技术，以至于好多人都以为以太网就是我们所说的网络。我们平时所说的交换机，其实专业说法叫以太网交换机。而一般的光纤交换机其实也是采用以太网技术，只是传输介质由网线改成光纤. 一般以太网的<strong>MTU</strong>设为<strong>1500</strong>字节，加上以太帧首部的长度14字节，也就是一个以太帧不会超过1500+14 = 1514字节. 最小帧长以太网的<strong>最小帧长</strong>是<strong>64</strong>字节, 凡是长度小于64字节的都是发生冲突而异常的无效帧(详见最小帧长).</p><p>网络的拓扑结构也是岁时代更新. 20世纪90年代总线拓扑流行, 现在已经流行星型拓扑结构, 中心连接通过集线器或交换机完成. 当然也有其他类型的网络:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/局域网拓扑.jpg" style="zoom:50%"><p><strong>无连接</strong>: 在发送和接收适配器之间没有握手</p><p><strong>不可靠</strong>: 接收适配器不向发送适配器发送应答或否定应答. 传送给网络层的数据报流可能有间隙, 如果应用程序使用TCP, 间隙将能弥补, 否则应用程序将看到该间隙.</p><h4 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h4><p>发送适配器在以太网帧(或其他网络层协议分组)中封装IP数据报.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/以太网帧.jpg" style="zoom:50%"><p><strong>前导码</strong>(Preamable): 用于同步接收方，发送方时钟速率. 前7个字节为10101010 的重复(前同步码, 像踏步走的121, 121循环), 最后一个字节是10101011(帧开始界定符), 结束后就说明接收方可以开始接收数据了. 但是<strong>前导码并不是链路层插入的, 而是物理层插入的</strong>!</p><p><strong>地址</strong>: <strong>6</strong>字节, 如果适配器接收具有匹配的目的地址或广播地址(如ARP分组)的帧, 它将帧中的数据提交给网络层协议</p><p><strong>类型</strong>: <strong>2</strong>字节, 指示较高层协议(网络层协议).</p><p><strong>数据</strong>: <strong>最小46B, 最大1500B</strong>. 链路层的MTU是1500字节. 以太网的最小帧长是64字节, 那么$64-6-6-2-4=46$字节.</p><p><strong>CRC</strong>: <strong>4</strong>字节, CRC循环冗余校验码.</p><h4 id="以太网的CSMA-CD"><a href="#以太网的CSMA-CD" class="headerlink" title="以太网的CSMA/CD"></a>以太网的CSMA/CD</h4><ol><li>适配器从网络层接收数据报并生成帧.</li><li>如果适配器侦听到信道空闲，开始传输帧. 如果侦听到信道忙，等待信道空闲再传输.</li><li>如果适配器传输整个帧而没有检测到另一个帧的传输，该适配器已经处理完帧.</li><li>如果适配器传输过程中检测到另一次传输, 中止并发送<strong>强化冲突信号</strong>, 放大冲突, 确保所有的其他传输方都知道发生了碰撞.</li><li>中止后, 适配器进入<strong>指数退避</strong>.</li></ol><h5 id="指数退避"><a href="#指数退避" class="headerlink" title="指数退避"></a>指数退避</h5><ul><li><p>比特时间: 对10 Mbps 以太网是 0.1 μs; 对K=1023, 等待时间约为50 msec</p></li><li><p>首次碰撞: 从$\{0,1\}$中选择$K$；时延是$K \cdot 512$bit 的传输时间</p></li><li><p>多次碰撞: 从$[0, 2^n] n \in Z$中选择$K$.</p></li></ul><h5 id="CSMA-CD的效率"><a href="#CSMA-CD的效率" class="headerlink" title="CSMA/CD的效率"></a>CSMA/CD的效率</h5><p>$t_{prop}$: LAN中的2站点之间的最大传播时间.</p><p>$t_{trans}$: 传输最长帧的时间.<br>$$<br>\eta = \frac{1}{1+5t_{prop/t_{trans}}}<br>$$<br>这样来看, 传播时间越短, 传输时间越长, 效率都越高.</p><h4 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h4><p>主要是10 BASE-5, 10 BASE-2, 10 BASE-T, 100 BASE-T, 100 BASE-T.</p><p>每个BASE前都有一个数字, 代表速度, 单位Mbps. BASE代表基带传输, 即baseband transmission.</p><p>10 BASE-5, 10 BASE-2最后的数字代表最大网段长度分别是500m和200m.</p><p>10 BASE-T, 100 BASE-T, 100 BASE-T最后的字母代表的是双绞线, 即twisted pair.</p><p>10 BASE-T, 100 BASE-T, 是速度为10/100Mbps的快速以太网, 使用了星型拓扑结构. 所有节点连接到中心的一台集线器, 节点和<strong>集线器</strong>最大的距离为100m.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/星型拓扑.jpg" style="zoom:50%"><h4 id="曼切斯特编码"><a href="#曼切斯特编码" class="headerlink" title="曼切斯特编码"></a>曼切斯特编码</h4><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/曼彻斯特编码.jpg" style="zoom:67%"><p>曼彻斯特编码在每个周期中都会发生一次<strong>突变</strong>, 以判断是否还有新的数据在传输. 这就是以太网帧结构前要加上前导码, 但却没有结束码的原因. 这种编码是由<strong>物理层</strong>实现的.</p><h3 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h3><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>集线器(Hub)可以看做是<strong>物理层</strong>中继器, 只对物理电信号放大中继，所有端口<strong>同属一个冲突域</strong>，主要用来延伸网络访问距离，扩展终端数量:</p><ul><li>来自一条链路的比特从其他所有链路出去(广播).</li><li>链路上以相同的速率传输.</li><li>无帧缓存(<strong>直通</strong>).</li><li>在集线器中<strong>无CSMA/CD</strong> : 适配器检测碰撞.</li><li>将多个结点连接成一个共享式 的局域网.</li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机(Switch)是<strong>链路层</strong>设备, 它的每个端口相当于一个集线器，原理是根据数据帧头的MAC地址转发帧到合适的端口，每个端口是一个<strong>独立的冲突域</strong>:</p><ul><li>存储, 转发以太网帧.</li><li>检查帧首部并基于MAC目的地址<strong>选择性</strong>地转发帧.</li><li>当帧在网段上转发时，使用<strong>CSMA/CD</strong> 访问网段.</li><li>无碰撞, 全双工.</li></ul><p>透明: 主机不知道交换机的存在.</p><p><strong>即插即用</strong>, 自学习: 交换机不必配置.</p><h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>交换机连接了三个LAN, 怎样决定向哪个LAN段转发帧?</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/交换机.jpg" style="zoom:67%"><p>每个交换机都有一个交换机表, 表项为<code>&lt;MAC地址, 接口, 时间戳&gt;</code>. 时间戳用于淘汰陈旧项. 交换机知道通过哪个接口可以到达哪个主机, 因为当帧收到时, 交换机记录下发送方的MAC和进入时的接口.</p><h5 id="过滤后转发"><a href="#过滤后转发" class="headerlink" title="过滤后转发"></a>过滤后转发</h5><p>如果目的站点所属LAN和源站点所属LAN相同, 则丢弃该帧. 如果目的站点所属LAN和源站点所属LAN不同, 则转发该帧. 如果目的站点所属的LAN未知, 则进行洪泛. 交换机减少了在不必要LAN内的重复扩散, 节约了资源.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/交换机隔离.jpg" style="zoom:67%"><p>即相同LAN段的帧通常不在其他LAN段上转发, 分割成了不同的碰撞域.</p><h4 id="集线器-交换机-路由器"><a href="#集线器-交换机-路由器" class="headerlink" title="集线器, 交换机, 路由器"></a>集线器, 交换机, 路由器</h4><table><thead><tr><th></th><th align="center">集线器</th><th align="center">路由器</th><th align="center">交换机</th></tr></thead><tbody><tr><td>流量隔离</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td>即插即用</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td>优化选路</td><td align="center">×</td><td align="center">√</td><td align="center">×</td></tr><tr><td>直通</td><td align="center">√</td><td align="center">×</td><td align="center">√</td></tr><tr><td>隔离广播</td><td align="center">×</td><td align="center">√</td><td align="center">×</td></tr><tr><td>所属层级</td><td align="center">物理层</td><td align="center">网络层</td><td align="center">链路层</td></tr></tbody></table><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>PPP(Point to Point Protocol，点到点协议) 是为在同等单元之间传输数据包这样的<strong>简单链路设计</strong>的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立<strong>点对点连接</strong>发送数据，使其成为各种主机, 网桥和路由器之间简单连接的一种共通的解决方案。</p><h4 id="PPP设计要求"><a href="#PPP设计要求" class="headerlink" title="PPP设计要求"></a>PPP设计要求</h4><ul><li><strong>分组成帧</strong>: 在数据链路帧中封装网络层数据报, 在相同时间承载任何网络层协议(不止是IP)的网络层数据.</li><li><strong>比特透明性</strong>: 在数据字段必须承载任何比特模式.</li><li><strong>连接活跃性</strong>: 对网络层检测, 通知链路故障.</li><li><strong>差错检测</strong>: 仅进行差错的检测而不纠正.</li><li><strong>网络层地址协商</strong>: 端点能学习/配置每个其他网络地址.</li></ul><p>不要求纠错/恢复, 流量控制, 数据重排序, 多点链路支持, 这些所有额外功能全部<strong>移交到高层</strong>处理.</p><h4 id="PPP数据帧"><a href="#PPP数据帧" class="headerlink" title="PPP数据帧"></a>PPP数据帧</h4><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/ppp.jpg" style="zoom:33%"><p><strong>标志</strong>: 定界符(成帧).</p><p><strong>地址</strong>: 不起作用 (仅是一个选项).</p><p><strong>控制</strong>:不起作用, 以后可能多控制字段.</p><p><strong>协议</strong>: 该帧交付的高层协议 (如 PPP-LCP, IP, IPCP等).</p><p><strong>信息</strong>: 高层承载的数据.</p><p><strong>校验</strong>: 对差错检测的冗余循环校验.</p><h5 id="比特填充-字节填充"><a href="#比特填充-字节填充" class="headerlink" title="比特填充/字节填充"></a>比特填充/字节填充</h5><p>有时候起始和结束的Flag<code>01111110</code> 也会出现在数据中啊, 可能是无意出现的. 处理方法其实和我们编程时字符串中用到的<strong>转义</strong>方法如出一辙. 如果数据中无意出现了<code>01111110</code>, 就在这个字节旁边额外加一个<code>01111110</code>, 是不是有转义内味了?</p><p>在接收方视角中, 在一排中出现<code>01111110 01111110</code> , 丢弃第一个字节, 继续数据接收即可. 如果是单个<code>01111110</code>, 那它就是起始和结束的Flag.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/ComputerNetwork/比特填充.jpg" style="zoom:67%"></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">AnNing</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://ADAning.github.io/posts/40485.html">https://ADAning.github.io/posts/40485.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">AnNing</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E9%9D%A2%E8%AF%95/"><span class="chip bg-color">面试</span> </a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="chip bg-color">计算机网络</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.mvaline-card{margin:1.5rem auto}.mvaline-card .card-content{padding:20px 20px 5px 20px}</style><div class="card mvaline-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="mvcomments" class="card-content" style="display:grid"></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/minivaline/MiniValine.min.js"></script><script>new MiniValine({el:"#mvcomments",appId:"M2K91TQqrwW698jR08LdugNz-gzGzoHsz",appKey:"b04G08nTf4B3kqCfOOY1urvC",mode:"xCss",placeholder:"评论暂不支持Latex公式, 但支持Markdown语法.",pathname:window.location.pathname,lang:"",adminEmailMd5:"ebbfbc84f11742e41a94a4e64b1d37ab",tagMeta:["管理员","小伙伴","访客"],master:["ebbfbc84f11742e41a94a4e64b1d37ab"],friends:["b5bd5d836c7a0091aa8473e79ed4c25e","adb7d1cd192658a55c0ad22a3309cecf","3ce1e6c77b4910f1871106cb30dc62b0","cfce8dc43725cc14ffcd9fb4892d5bfc"],math:!1,md:!0,enableQQ:!0,NoRecordIP:!1,visitor:!1,maxNest:6,pageSize:12,serverURLs:"",emoticonUrl:["https://cdn.jsdelivr.net/npm/alus@latest","https://cdn.jsdelivr.net/gh/MiniValine/qq@latest","https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest","https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest","https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest","https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"]})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/39405.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/featureimages/19.jpg" class="responsive-img" alt="机器学习之逻辑回归与线性回归"> <span class="card-title">机器学习之逻辑回归与线性回归</span></div></a><div class="card-content article-content"><div class="summary block-with-text">2020.8.22: 附加了后续的逻辑回归部分. 逻辑回归想要了解逻辑回归，必须了解线性回归. 线性回归 Logistcs Regression线性回归是监督学习中最简单的模型了, 它具有非常好的可解释性, 也有一种简洁的典雅美.</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-08-05 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-category">机器学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"><span class="chip bg-color">线性回归</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/46329.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/featureimages/16.jpg" class="responsive-img" alt="机器学习之特征缩放"> <span class="card-title">机器学习之特征缩放</span></div></a><div class="card-content article-content"><div class="summary block-with-text">特征缩放 Feature scaling特征缩放还有另外一个名字, 叫做标准化. 标准化能够尽可能的使得模型快速收敛, 如果某个特征的方差比别的特征大几个数量级的话, 用距离度量的算法就会受到非常大的影响, 比如神经网络, SVM, 逻辑回</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-08-03 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-category">机器学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE/"><span class="chip bg-color">特征缩放</span></a></div></div></div></div></article></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});const i="expanded";let c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).hide(),a.removeClass("l9")):(c.addClass(i).show(),a.addClass("l9"));{let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}return}})})</script></main><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2020</span> <a href="/about" target="_blank">AnNing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">309k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/ADAning" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:695439722@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="https://www.zhihu.com/people/nzhu-27" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/nzhu-27" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-angle-double-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/instantpage/instantpage.js" type="module"></script></body></html>