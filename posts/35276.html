<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Transformer-XL与XLNet, DaNing的博客"><meta name="description" content="DaNing的个人博客."><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>Transformer-XL与XLNet | DaNing的博客</title><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/favicon.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/css/matery.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/css/my.css"><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">DaNing的博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>时间轴</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-tools" style="zoom:.6"></i> <span>工具</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/shortcut"><i class="fas fa-rocket" style="margin-top:-20px;zoom:.6"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu"><i class="fas fa-wheelchair" style="margin-top:-20px;zoom:.6"></i> <span>帮你百度</span></a></li><li><a href="/markdown"><i class="fab fa-markdown" style="margin-top:-20px;zoom:.6"></i> <span>Markdown</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">DaNing的博客</div><div class="logo-desc">DaNing的个人博客.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-tools"></i> 工具 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/shortcut" style="margin-left:75px"><i class="fa fas fa-rocket" style="position:absolute;left:50px"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu" style="margin-left:75px"><i class="fa fas fa-wheelchair" style="position:absolute;left:50px"></i> <span>帮你百度</span></a></li><li><a href="/markdown" style="margin-left:75px"><i class="fa fab fa-markdown" style="position:absolute;left:50px"></i> <span>Markdown</span></a></li></ul></li></ul></div></div></nav></header><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/featureimages/5.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Transformer-XL与XLNet</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/NLP/"><span class="chip bg-color">NLP</span> </a><a href="/tags/Transformer/"><span class="chip bg-color">Transformer</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-10-14</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-03-18</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 8.1k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 34 分</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><blockquote><p>本文前置知识:</p><ul><li>Transformer(Masked Self - Attention和FFN)</li><li>BERT(与XLNet做对比)</li><li>Seq2Seq(AutoRegressive &amp; AutoEncoding)</li></ul><p><strong>2020.10.26</strong>: 更新了Transformer - XL的隐态更新维度分析.</p></blockquote><h1 id="Transformer-XL与XLNet"><a href="#Transformer-XL与XLNet" class="headerlink" title="Transformer - XL与XLNet"></a>Transformer - XL与XLNet</h1><p>本文是Transformer - XL和XLNet论文的阅读笔记和个人理解(实际上还包括Vanilla Transformer).</p><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>这两篇论文都没有从Transformer开始, 而是从<a href="https://arxiv.org/abs/1808.04444" target="_blank" rel="noopener">Character-Level Language Modeling with Deeper Self-Attention</a>开始, 该模型利用了Self - Attention在更深层次的语言模型上进行字符级建模, 因内容比单词级更长, 所以提出了直接将内容按照固定大小划分为<strong>Segment</strong>处理的方法. 该在文中被称为Vanilla Transformer, 被多次提及. 分段的方式伴随着多种缺点, Vanilla Transformer对Segment的划分没有进行任何优化. 而Transformer - XL对该模型存在的问题进行了优化, 而XLNet将Transformer - XL和BERT的优势结合到了一起.</p><h2 id="Vanilla-Transformer"><a href="#Vanilla-Transformer" class="headerlink" title="Vanilla Transformer"></a>Vanilla Transformer</h2><p>中使用的Transformer被称为Vanilla Transformer(普通Transformer). 我们只需要知道它将一个Masked 多头Self - Attention和一个由两层全连接构成的FFN称为一个Transformer Layer, 然后堆叠多层Transformer Layer. 训练时使用<strong>语言模型</strong>的方式, 采用<strong>字符级</strong>数据. 它能够堆叠的非常深, 达到了64层, 其实它也是通过加深模型的方式来增长前文依赖能力的.</p><p>如果没有Transformer基础建议看我写过的<code>&lt;Transformer精讲&gt;</code>. 关于Vanilla Transformer, 其他具体内容如果想了解可以去看原论文.</p><p>在Transformer中通常需要设定一个固定的长度, 如果输入序列长小于固定长则进行<strong>填充</strong>. 因为使用字符级数据, 所以经常会出现大于序列长的情况. 它采用分段处理, 引入辅助函数训练.</p><p>与Transformer一样, 训练阶段, 模型能够一次处理<strong>整段数据</strong>:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/transformerxl1.jpg" style="zoom:50%"><p>评估阶段, 模型需要按照自回归每次前进一个Token:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/transformerxl2.jpg" style="zoom:67%"><h2 id="Transformer-XL"><a href="#Transformer-XL" class="headerlink" title="Transformer - XL"></a>Transformer - XL</h2><p>Transformer - XL出自论文<a href="https://arxiv.org/abs/1901.02860" target="_blank" rel="noopener">Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context</a>. 其中XL指的是extra - long. 作者主要通过Segment - Level Recurrence的方式来缓解Transformer中的内容长度限定问题, 其衍生问题由Relative Positional Encoding解决.</p><p>在Vanilla Transformer中的分段导致了两个问题:</p><ol><li><strong>依赖</strong>的最大长度被固定长这个参数严格的限制了.</li><li>在划分时很有可能会<strong>截断上下文的含义</strong>, 导致不同的Segment之间考虑不到上下文联系, 这被称为上下文碎片化(Context framentation).</li></ol><p>不同段之间的梯度传播会被分段而<strong>截断</strong>:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/transformerxl5.jpg" style="zoom:50%"><p>这两个缺陷是Transformer - XL改进的动机.</p><h3 id="Segment-Level-Recurrence-with-State-Reuse"><a href="#Segment-Level-Recurrence-with-State-Reuse" class="headerlink" title="Segment - Level Recurrence with State Reuse"></a>Segment - Level Recurrence with State Reuse</h3><p>最首要的想法就是建立前后Segment之间的<strong>联系</strong>, 想办法将前面Segment的信息传到后面.</p><p>作者直接以Segment为单位进行操作, 每次都将<strong>同层</strong>上个Segment的隐态<strong>暂存</strong>下来, 而并非是对隐态重新计算. 但<strong>不保存梯度</strong>, 因为我们只是用同层的上个Segment隐态做为一种记忆信息对当前Segment产生影响, 并不需要进行反向传播. 储存的隐态数量尽可能多的.</p><p>$$<br>\begin{array}{l}<br>\widetilde{\mathbf{h}}_{\tau+1}^{n-1}=\left[\mathrm{SG}\left(\mathbf{h}_{\tau}^{n-1}\right) \circ \mathbf{h}_{\tau+1}^{n-1}\right] \\<br>\mathbf{q}_{\tau+1}^{n}, \mathbf{k}_{\tau+1}^{n}, \mathbf{v}_{\tau+1}^{n}=\mathbf{h}_{\tau+1}^{n-1} \mathbf{W}_{q}^{\top}, \widetilde{\mathbf{h}}_{\tau+1}^{n-1} \mathbf{W}_{k}^{\top}, \widetilde{\mathbf{h}}_{\tau+1}^{n-1} \mathbf{W}_{v}^{\top} \\<br>\mathbf{h}_{\tau+1}^{n}=\text { Transformer-Layer }\left(\mathbf{q}_{\tau+1}^{n}, \mathbf{k}_{\tau+1}^{n}, \mathbf{v}_{\tau+1}^{n}\right)<br>\end{array}<br>$$</p><p>其中$n$ 代表层数, $\tau$ 代表Segment号. $\mathrm{SG}(\cdot)$ 代表不求梯度, 不算作反向传播的一部分. 注意上面的式子, $\mathbf{k}_{\tau+1}^{n}$ 和 $\mathbf{v}_{\tau+1}^{n}$ 都是由当前Segment隐态和上个Segment隐态Concat后的$\widetilde{\mathbf{h}}_{\tau+1}^{n-1}$ 生成的, 而$\mathbf{q}_{\tau+1}^{n}$ <strong>仅由当前Segment隐态$\mathbf{h}_{\tau+1}^{n-1}$影响</strong>. 每个Segment都做相同的动作, 因此称该方法为Segment - Level Recurrence.</p><p>在训练时仍然每次前进一段:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/transformerxl3.jpg" style="zoom:50%"><p>与Vanilla Transformer不同的是, 因为能够直接<strong>复用</strong>整个Segment的信息, 能够极大加快Evaluation的速度, 所以每次前进Segment个Token:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/transformerxl6.jpg" style="zoom:50%"><blockquote><p>如果对前进Segment个Token有些模糊, 还是要理解作者是以整个Segment为单位进行操作的, 即使是进行自回归运算, 也是直接生成Segment个输出, 并输入进下个Segment.<br>$$<br>\mathbf{h}_{\tau}=f\left(\mathbf{h}_{\tau-1}, \mathbf{E}_{\mathbf{s}_{\tau}}+\mathbf{U}_{1: L}\right)<br>$$<br>如果在对前一个Segment的隐态和当前时刻隐态做Concat这个操作有疑惑, 我们来分析一下在这个计算过程中维度的变化. 请记住一个结论: <strong>Transformer隐态输出大小取决于Query的序列长度</strong>.</p><p>假设前一时刻隐态$\mathbf{h}_{\tau}^{n-1}$ 和当前时刻隐态$\mathbf{h}_{\tau+1}^{n-1}$ 的Size为$L\times d$, $W_q^T$, $W_v^T$, $W_k^T$ 的Size为$d_k \times d$. 在做完Concat后, 拼接后隐态$\widetilde{\mathbf{h}}_{\tau+1}^{n-1}$ Size为$2L \times d$, 看一下Attention分数的计算:<br>$$<br>\displaylines{<br>\mathbf{q}_{\tau+1}^{n}, \mathbf{k}_{\tau+1}^{n}, \mathbf{v}_{\tau+1}^{n}=\mathbf{h}_{\tau+1}^{n-1} \mathbf{W}_{q}^{\top}, \widetilde{\mathbf{h}}_{\tau+1}^{n-1} \mathbf{W}_{k}^{\top}, \widetilde{\mathbf{h}}_{\tau+1}^{n-1} \mathbf{W}_{v}^{\top} \\<br>\text{Attention Score}_{\tau+1}^n = \frac{\mathbf{q}_{\tau+1}^{n}{\mathbf{k}_{\tau+1}^{n}}^T}{\sqrt{d_k}}\mathbf{v}_{\tau+1}^{n}<br>}<br>$$<br>重复一遍之前的话, $\mathbf{k}_{\tau+1}^{n}$ 和 $\mathbf{v}_{\tau+1}^{n}$ 都是由当前Segment隐态和上个Segment隐态Concat后的$\widetilde{\mathbf{h}}_{\tau+1}^{n-1}$ 生成的, 而$\mathbf{q}_{\tau+1}^{n}$ <strong>仅由当前Segment隐态$\mathbf{h}_{\tau+1}^{n-1}$影响</strong>.</p><p>在求得分时, $\mathbf{q}_{\tau+1}^{n}$ 的维度是$L \times d_k$, $\mathbf{k}_{\tau+1}^{n}$ 和的$\mathbf{v}_{\tau+1}^{n}$维度都是$2L \times d$, 求完$\mathbf{q}_{\tau+1}^{n} \cdot {\mathbf{k}_{\tau+1}^{n}}^T$ 后维度是$L\times 2L$, 然后与$\mathbf{v}_{\tau+1}^{n}$ 再相乘, 维度变成$L\times d_k$. 乘完后的计算维度是与Transformer<strong>保持一致</strong>的.</p></blockquote><p>并且还能更好的联系前文信息, 每次能够依赖的最大长度也从$\text{Segment Length}$ 提升到$\text{Layer} \times \text{Segment Length}$的倍数:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/transformerxl4.jpg" style="zoom:67%"><h3 id="Relative-Positional-Encoding"><a href="#Relative-Positional-Encoding" class="headerlink" title="Relative Positional Encoding"></a>Relative Positional Encoding</h3><p>虽然已经利用Segment - Level Recurrence来解决固定长问题, 但在计算<strong>位置编码</strong>时候还没有彻底将<strong>段递归</strong>的思想融合进去.</p><h4 id="Absolute-Positional-Encoding"><a href="#Absolute-Positional-Encoding" class="headerlink" title="Absolute Positional Encoding"></a>Absolute Positional Encoding</h4><p>在Transformer中, 使用的是绝对位置编码:</p><p>$$<br>\begin{aligned}<br>\mathbf{A}_{i, j}^{\mathrm{abs}}&amp;= \left[ \mathbf{W}_{q}\left( \mathbf{E}_{x_{i}}+\mathbf{U}_i \right)\right]^{\top} \mathbf{W}_{k}\left(\mathbf{E}_{x_j}+\mathbf{U}_j\right)\\<br>&amp;=\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{E}_{x_{j}}}_{(a)}+\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{U}_{j}}_{(b)}<br>+\underbrace{\mathbf{U}_{i}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{E}_{x_{j}}}_{(c)}+\underbrace{\mathbf{U}_{i}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{U}_{j}}_{(d)}<br>\end{aligned}<br>$$</p><p>这个式子是由Transformer中的Attention拆来的, 其中$\mathbf{W}$ 代表权重矩阵, $\mathbf{E}$ 代表某个Token的Embedding, $\mathbf{U}$ 代表位置编码.</p><p>这样的位置编码在同一个Segment中是生效的, 但是对于不同的Segment就无法区分两个Segment中的同一对应位置, 即<strong>绝对位置不同</strong>, 但<strong>位置编码相同</strong>. 因此作者提出使用相对位置编码来解决该问题.</p><h4 id="Relative-Positional-Encoding-1"><a href="#Relative-Positional-Encoding-1" class="headerlink" title="Relative Positional Encoding"></a>Relative Positional Encoding</h4><p>作者先是说明了位置编码的作用:</p><blockquote><p>Conceptually, the positional encoding gives the model a <strong>temporal clue</strong> or “<strong>bias</strong>“ about how information should be gathered.</p></blockquote><p>概念上来说位置编码告诉模型一些如何收集信息的时序线索或者”偏置”.</p><blockquote><p>when a query vector $q_{τ,i}$ attends on the key vectors $k_{τ,≤i}$, it does not need to know the absolute position of each key vector to identify the temporal order of the segment. Instead, it suffices to know the relative distance between each key vector $k_{τ,j}$ and itself $q_{τ,i}$, i.e. $i−j$.</p></blockquote><p>但是在进行查询的时候, 每个key的绝对位置实际上通常是<strong>无关紧要</strong>的, 但与query的相对位置却非常关键. 也就是说我只要知道Query和Key的距离就足够了, 根本不关心它们到底处于原文中的哪个具体位置. 所以可以引入相对位置编码来告诉模型Token之间的相对位置关系, 从而代替更为复杂的绝对位置编码.</p><p>$$<br>\mathbf{A}_{i, j}^{\mathrm{rel}} =\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_{j}}}_{(a)}+\underbrace{\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k, R} \mathbf{R}_{i-j}}_{(b)}<br>+\underbrace{u^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_{j}}}_{(c)}+\underbrace{v^{\top} \mathbf{W}_{k, R} \mathbf{R}_{i-j}}_{(d)}<br>$$</p><p>主要关注两个<strong>替换点</strong>:</p><ul><li>所有与Key对应的绝对位置$j$ 相关的项$\mathbf{U}_j$ 应该被替换为相对位置项$\mathbf{R}_{i-j}$.</li><li>由于Query总出于同一位置, 所有与Query对应的绝对位置$i$ 相关的项$\mathbf{U}_i^{\top}\mathbf{W}_q^{\top}$ 也应该被替换掉, 在这里替换成两个可训练参数$u$ 和$v$ .</li></ul><p>其中$\mathbf{R}_{i-j}$的编码方式与Transformer中的<strong>正余弦</strong>位置编码方式相同.</p><p>对于相对位置的四项, 作者做了汇总, 并给它们下了直观含义:</p><blockquote><p>term (a) represents contentbased addressing, term (b) captures a contentdependent positional bias, term (c) governs a global content bias, and (d) encodes a global positional bias.</p></blockquote><table><thead><tr><th align="center">项数</th><th align="center">绝对位置表示</th><th align="center">相对位置表示</th><th>相对位置含义</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">$\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{E}_{x_{j}}$</td><td align="center">$\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_{j}}$</td><td>基于内容的寻址</td></tr><tr><td align="center">b</td><td align="center">$\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{U}_{j}$</td><td align="center">$\mathbf{E}_{x_{i}}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k, R} \mathbf{R}_{i-j}$</td><td>依赖内容的位置偏置</td></tr><tr><td align="center">c</td><td align="center">$\mathbf{U}_{i}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{E}_{x_{j}}$</td><td align="center">$u^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_{j}}$</td><td>全局内容偏置</td></tr><tr><td align="center">d</td><td align="center">$\mathbf{U}_{i}^{\top} \mathbf{W}_{q}^{\top} \mathbf{W}_{k} \mathbf{U}_{j}$</td><td align="center">$v^{\top} \mathbf{W}_{k, R} \mathbf{R}_{i-j}$</td><td>全局位置偏置</td></tr></tbody></table><blockquote><p>我开始很难理解(c)和(d)的含义到底是如何观察出来的. 如果从映射和查询的角度去理解的话, 可以看作是权重矩阵左侧的内容做了一次Embedding, 投影进潜在空间, 然后与权重矩阵右侧的内容计算得分.</p><p>个人理解还是有些模糊, 可解释性不够好.</p></blockquote><p>在加上相对位置编码后, 整个过程就完善了, 形成一个闭环:<br>$$<br>\begin{aligned}<br>\widetilde{\mathbf{h}}_{\tau}^{n-1}=&amp;\left[\mathrm{SG}\left(\mathbf{m}_{\tau}^{n-1}\right) \circ \mathbf{h}_{\tau}^{n-1}\right] \\<br>\mathbf{q}_{\tau}^{n}, \mathbf{k}_{\tau}^{n}, \mathbf{v}_{\tau}^{n}=&amp; \mathbf{h}_{\tau}^{n-1} \mathbf{W}_{q}^{n \top}, \widetilde{\mathbf{h}}_{\tau}^{n-1} \mathbf{W}_{k, E}^{n}, \widetilde{\mathbf{h}}_{\tau}^{n-1} \mathbf{W}_{v}^{n \top} \\<br>\mathbf{A}_{\tau, i, j}^{n}=&amp; \mathbf{q}_{\tau, i}^{\top} \mathbf{k}_{\tau, j}^{n}+\mathbf{q}_{\tau, i}^{n} \mathbf{W}_{k, R}^{n} \mathbf{R}_{i-j}<br>+u^{\top} \mathbf{k}_{\tau, j}+v^{\top} \mathbf{W}_{k, R}^{n} \mathbf{R}_{i-j} \\<br>\mathbf{a}_{\tau}^{n}=&amp; \text { Masked-Softmax }\left(\mathbf{A}_{\tau}^{n}\right) \mathbf{v}_{\tau}^{n} \\<br>\mathbf{o}_{\tau}^{n}=&amp; \text { LayerNorm }\left(\operatorname{Linear}\left(\mathbf{a}_{\tau}^{n}\right)+\mathbf{h}_{\tau}^{n-1}\right) \\<br>\mathbf{h}_{\tau}^{n}=&amp; \text { Positionwise-Feed-Forward }\left(\mathbf{o}_{\tau}^{n}\right)<br>\end{aligned}<br>$$<br>其中$\mathbf{m}_{\tau}^{n-1}$ 指的是第$\tau$ 个Segment时GPU缓存中的所有第$n-1$ 层的隐态.</p><blockquote><p>推荐阅读:</p><ul><li><a href="http://ai.googleblog.com/2019/01/transformer-xl-unleashing-potential-of.html" target="_blank" rel="noopener">Transformer-XL: Unleashing the Potential of Attention Models</a> 是谷歌官方发布的Blog, 里面有动图.</li></ul></blockquote><h2 id="XLNet"><a href="#XLNet" class="headerlink" title="XLNet"></a>XLNet</h2><p>XLNet出自论文<a href="http://arxiv.org/abs/1906.08237" target="_blank" rel="noopener">XLNet: Generalized Autoregressive Pretraining for Language Understanding</a>.</p><p>虽然BERT在各类任务上的出色表现, 但BERT是一个<strong>自编码</strong>(Auto Encoding)模型, 相较与<strong>自回归</strong>(Auto Regressive)模型, 自编码模型在面对<strong>生成式</strong>的任务是天生具有劣势的(我们后面再提). XLNet尝试在自回归的基础上将BERT身上的优点吸取过来.</p><p>但是怎么才能在自回归模型中引入双向捕捉上下文的能力呢? 在先前的任务中, AR模型一般只能通过Forward和Backward两次单向编码来尝试捕捉上下文, 但并没有双向捕捉上下文效果来的理想, 下游任务又非常需要这种双向建模的能力. 自回归和自编码的模型<strong>各有优劣</strong>, 很多时候特点既是一种<strong>优势</strong>, 也是一种<strong>限制</strong>. AR模型受限于自身结构, 不能从结构上改变. 作者巧妙的想到了利用<strong>打乱Token之间的顺序</strong>来获取上下文.</p><h3 id="Why-not-BERT"><a href="#Why-not-BERT" class="headerlink" title="Why not BERT?"></a>Why not BERT?</h3><h4 id="Disadvantage-of-BERT"><a href="#Disadvantage-of-BERT" class="headerlink" title="Disadvantage of BERT"></a>Disadvantage of BERT</h4><p>XLNet的作者指出了BERT的两个<strong>致命缺点</strong>:</p><ol><li><p>被BERT使用的人工制造符号譬如<code>[MASK]</code>完全贯穿于BERT的<strong>预训练</strong>过程, 但在用<strong>实际数据</strong>做Fine - tune时根本没有, 导致了预训练和微调之间的<strong>差异</strong>. 我记得在BERT中, 作者提到了缓解这个问题的方案, 但不能从根本上解决这个问题:</p><blockquote><p>在Fine tune的时候不可能对单词进行Mask, 这样就会导致预训练和微调的不匹配, 为缓解这种问题, 并非总是将选中的单词Mask, 而是在每个句子中, 有15%的词会被选中, 在选中单词后有三种可能性:</p><ol><li><strong>80%</strong>的概率将被选中的单词替换为<code>[MASK]</code>.</li><li><strong>10%</strong>的概率将被选中的单词替换为<strong>随机词</strong>.</li><li><strong>10%</strong>的概率对被选中的单词<strong>不进行替换</strong>.</li></ol></blockquote></li><li><p>BERT假设被Mask掉的Token与句子中剩下的内容是独立的, 但在实际任务中普遍有远程依赖.</p><blockquote><p>比如”New York is a city.” 假设Mask了”New”和”York”两个词语, 那么在已知”is a city”的情况下, 就不太可能预测准确.</p></blockquote></li></ol><h4 id="Comparsion-of-AutoEncoding-and-AutoRegressive"><a href="#Comparsion-of-AutoEncoding-and-AutoRegressive" class="headerlink" title="Comparsion of AutoEncoding and AutoRegressive"></a>Comparsion of AutoEncoding and AutoRegressive</h4><p>假设你真的不知道AE和AR是什么意思, 我们用大白话给AE何AR重新下个定义吧:</p><ul><li><p>自回归模型(AR): 将上一时刻的输出作为输入, 对当前时刻输出进行预测.</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/xlnet2.jpg" style="zoom:67%"></li><li><p>自编码模型(AE): 把完整的内容破坏掉一部分作为输入, 来预测被破坏掉的那部分.</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/xlnet3.jpg" style="zoom:67%"></li></ul><blockquote><p>上述图片出自NLPCC 2020中科大讯飞和HIT - SCIR做的报告&lt;Revisiting Pre-Trained Models for Natural Language Processing&gt;.</p></blockquote><p>对给定的文本输入序列$\mathbf{x}=\left[x_{1}, \cdots, x_{T}\right]$, $e(x)$ 代表Token $x$ 的Embedding.</p><p>自回归模型的任务目标是最大似然该函数:<br>$$<br>\max _{\theta}\quad \log p_{\theta}(\mathbf{x})=\sum_{t=1}^{T} \log p_{\theta}\left(x_{t} \mid \mathbf{x}_{&lt;t}\right)=\sum_{t=1}^{T} \log \frac{\exp \left(h_{\theta}\left(\mathbf{x}_{1: t-1}\right)^{\top} e\left(x_{t}\right)\right)}{\sum_{x^{\prime}} \exp \left(h_{\theta}\left(\mathbf{x}_{1: t-1}\right)^{\top} e\left(x^{\prime}\right)\right)}<br>$$<br>但是对于AE模型来说(主要以BERT作为对比对象), 由于会选中15%的Token做Mask, 假设被污染的Token用$\hat{\mathbf{x}}$ 表示, 自编码模型的任务目标是从<strong>带噪声</strong>的$\hat{\mathbf{x}}$ 中重建$\overline{\mathbf{x}}$:<br>$$<br>\max _{\theta}\quad \log p_{\theta}(\overline{\mathbf{x}} \mid \hat{\mathbf{x}}) \approx \sum_{t=1}^{T} m_{t} \log p_{\theta}\left(x_{t} \mid \hat{\mathbf{x}}\right)=\sum_{t=1}^{T} m_{t} \log \frac{\exp \left(H_{\theta}(\hat{\mathbf{x}})_{t}^{\top} e\left(x_{t}\right)\right)}{\sum_{x^{\prime}} \exp \left(H_{\theta}(\hat{\mathbf{x}})_{t}^{\top} e\left(x^{\prime}\right)\right)}<br>$$</p><p>其中当Token $x_t$ 被Mask时$m_t=1$, 其他时候为0. $H_\theta$ 是Transformer将长度为$T$ 的文本序列$\mathbf{x} $ 映射成隐态向量$H_{\theta}(\mathbf{x})=\left[H_{\theta}(\mathbf{x})_{1}, H_{\theta}(\mathbf{x})_{2}, \cdots, H_{\theta}(\mathbf{x})_{T}\right]$ .</p><p>注意这两个目标函数, 首先条件不同, 其次是隐态表示不同. AR模型中因为只能看到前文的信息, 而AE模型能够看到全部的上下文信息. 将二者比较后, 作者得出三个结论:</p><ul><li><p><strong>独立假设</strong>: 这里强调了在自编码任务目标中的$\approx$, BERT假设在给定$\hat{\mathbf{x}}$ 的情况下被Mask的词是相互独立的. 而AR模型不需要独立性假设.</p></li><li><p><strong>输入噪声</strong>: 在预训练时会出现特殊的人造Token, Fine - tune时没有, 导致不匹配. 而AR模型不对输入引入噪声, 所以不会遇到该问题.</p></li><li><p><strong>上下文依赖</strong>: AR模型只能捕捉到位置位于前面的信息$h_\theta(\mathbf{x_{1:t-1}})$, BERT能更好的捕捉双向上下文信息$H_\theta(\mathbf{x})_t$.</p><blockquote><p>对于双向捕捉可以参考<a href="https://adaning.github.io/posts/3996.html">ELMo, GPT, BERT</a>.</p></blockquote></li></ul><p>作者观察到的这三点非常重要, 作为模型的改进方向.</p><p>此外, AR模型的特性能带来一个AE模型不能带来的优势, 这也是BERT为捕捉双向上下文付出的代价. 我们考虑一个场景:</p><ul><li>BERT要对<code>[New, York, is, a, city]</code> 中的<code>[New, York]</code> 进行预测, 作为AE模型对<code>[New, York]</code> 做了Mask.</li><li>XLNet要对<code>[is, a, city, New, York]</code> 中的<code>[New, York]</code> 进行预测, 作为AR模型, 需要先预测出<code>[New]</code>, 再利用<code>[New]</code> 的信息预测<code>[York]</code>.</li></ul><p>那么这两种方式产生的信息量是绝对不一样的:<br>$$<br>\begin{aligned}<br>\mathcal{J}_{\mathrm{BERT}} &amp;=\log p(\text { New } \mid \text { is a city })+\log p(\text { York } \mid \text { is a city }) \\<br>\mathcal{J}_{\mathrm{XLNet}} &amp;=\log p(\mathrm{New} \mid \text { is a city })+\log p(\text { York } \mid \mathrm{New}, \text { is a city })<br>\end{aligned}<br>$$<br>很明显, XLNet因为是AR模型, 永远都能学到更多的依赖对. 至于为什么可以在二者输入不一样的情况下进行比较, 在读完下一小节后你就会恍然大悟.</p><blockquote><p>在附录中还有更多的比对, 更详细的内容请自行阅读原论文.</p></blockquote><h3 id="Permutation-Language-Model-Based-on-AutoRegressive-Model"><a href="#Permutation-Language-Model-Based-on-AutoRegressive-Model" class="headerlink" title="Permutation Language Model Based on AutoRegressive Model"></a>Permutation Language Model Based on AutoRegressive Model</h3><p>由于AR语言模型比较特殊, 不好实现像BERT那样双向捕捉上下文的效果. 作者提出用<strong>置换</strong>的方法, 既能保留AR模型的优势, 又允许模型捕捉上下文.</p><p>对于给定长度为$T$ 的序列$\mathbf{x}$, 总共有$T!$ 种不同的排列方式. 如果模型参数能通过多次随机的句子排列<strong>共享</strong>, 那么AR模型就能将所有位置上的信息结合到一起.</p><p>假设$\mathcal{Z}_{T}$ 代表长度为$T$ 的序列下标, $z_t$ 代表第$t$ 个元素, $\mathbf{z}_{&lt;t}$ 代表置换后的前$t-1$ 个元素.</p><p>沿着之前AR模型的目标, 现在给置换语言模型(PLM)的基本优化目标重新下个定义吧:<br>$$<br>\max _{\theta} \mathbb{E}_{\mathbf{z} \sim \mathcal{Z}_{T}}\left[\sum_{t=1}^{T} \log p_{\theta}\left(x_{z_{t}} \mid \mathbf{x}_{\mathbf{z}&lt;t}\right)\right]<br>$$<br>我们的目标只是单纯的从原来有序的输入序列变成了<strong>位置随机重排</strong>后的序列, 这样在做自回归时就能够看到原本不属于该位置的元素, 这样就能双向捕捉上下文.</p><blockquote><p>作者在这里强调, 仅生成一个置换后的新下标序列, 而输入序列的原文顺序是不变的. 沿用与原始输入相对应的位置编码, 并依靠<strong>Attention</strong>来实现对下标的置换. 因为在<strong>FineTuning</strong>期间文本的顺序是正常而<strong>不发生置换</strong>的.</p></blockquote><p>作者给出了一张对置换部分的阐述图, 假设当前要对$x_3$ 进行预测, 在置换语言模型中只能通过Attention来关注置换后序列在$3$ 前的输入:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/xlnet1.jpg" style="zoom:67%"><p>例如左上角, 分解顺序为$3 \rightarrow 2 \rightarrow 4 \rightarrow 1$ 时, 只能对之前的隐态$\text{mem}$ 做Attention. 右上角, 分解顺序为$2 \rightarrow 4 \rightarrow 3 \rightarrow 1$ 时, 只能对置换顺序在$3$ 前的$2$ 和 $4$ 做Attention. 下面两幅图同理.</p><blockquote><p>是不是有些巧妙? 对, 置换的方法确实比较巧妙, 但是请思考一个问题, 假设置换后的顺序为$2 \rightarrow 4 \rightarrow 3 \rightarrow 1$, 马上就要预测$x_3$ 了, 由于打乱了顺序, 模型怎才能知道它要预测的是$x_3$ 还是 $x_1$ 呢?</p></blockquote><h3 id="Two-Stream-Self-Attention-for-Target-Aware-Representations"><a href="#Two-Stream-Self-Attention-for-Target-Aware-Representations" class="headerlink" title="Two - Stream Self - Attention for Target - Aware Representations"></a>Two - Stream Self - Attention for Target - Aware Representations</h3><h4 id="Target-Aware"><a href="#Target-Aware" class="headerlink" title="Target - Aware"></a>Target - Aware</h4><p>由于采用了置换的方式, 所以按照Transformer的方法处理目标可能会遇到一些问题.</p><p>如果我们沿用之前Transformer的方式, $h_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}\right)$ 代表$\mathbf{X}_{\mathbf{Z}&lt;t}$ 的隐态, 来计算下一个单词的分布:<br>$$<br>p_{\theta}\left(X_{z_{t}}=\right.\left.x \mid \mathbf{x}_{\mathbf{z}&lt;t}\right)=\frac{\exp \left(e(x)^{\top} h_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}\right)\right)}{\sum_{x^{\prime}} \exp \left(e\left(x^{\prime}\right)^{\top} h_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}\right)\right)}<br>$$<br>由于我们之前<strong>打乱</strong>了原有的句子顺序, 模型完全不知道该预测哪个Token了. 对于未知的所有Token, 它们有可能不在原来的位置上, 也有可能在原来的位置上. 换句话说, 如果使用Transformer的方法, 下一个要预测的Token分布与它原来的<strong>位置</strong>就没有关联了.</p><p>因此必须将下一个要预测的Token通过某种方式<strong>显式</strong>的告诉模型, “哦它才是打乱顺序后我该预测的下一个Token”, 这也就是论文中说的<strong>Target - Aware</strong>:<br>$$<br>p_{\theta}\left(X_{z_{t}}=x \mid \mathbf{x}_{z&lt;t}\right)=\frac{\exp \left(e(x)^{\top} g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)\right)}{\sum_{x^{\prime}} \exp \left(e\left(x^{\prime}\right)^{\top} g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)\right)}<br>$$<br>$g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_{t}\right)$ 代表加入目标位置信息的表示方法.</p><h4 id="Two-Stream-Self-Attention"><a href="#Two-Stream-Self-Attention" class="headerlink" title="Two - Stream Self - Attention"></a>Two - Stream Self - Attention</h4><p>因为置换把要预测的Token的<strong>位置信息</strong>直接搞掉了, 所以必须通过其他方式提供位置信息. 我们必须符合以下两个点的限制:</p><ol><li>预测$x_{z_t}$ 时, $g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_t\right) $ 不能$z_t$ 处的内容信息$x_{z_t}$, 只能使用$z_t$ 处的位置信息.</li><li>在预测一个位置上$j&gt;t$ 的Token$x_{z_j}$ 时, $g_{\theta}\left(\mathbf{x}_{\mathbf{z}&lt;t}, z_t\right) $ 应该将$x_{z_t}$ 编码来提供全部的上下文信息.</li></ol><p>基于这两点规则, XLNet采用<strong>双流注意力</strong>机制, 其中一种注意力提供<strong>上下文</strong>信息, 另一种提供<strong>位置</strong>信息.</p><ul><li>$h_\theta\left(\mathbf{x}_{\mathbf{z}\leq t}\right)$, 记为$h_{z_t}$, 表示包括$x_{z_t}$ 在内的编码的上下文信息, 与标准的Transformer相同, 被称作为<strong>内容流</strong>(Content Stream).</li><li>$g_\theta\left(\mathbf{x}_{\mathbf{z}_&lt;t}, z_t\right)$, 记为$g_{z_t}$, 表示仅包括$\mathbf{x}_{\mathbf{z} &lt; t}$ 在内的上下文信息和$z_t$ 的位置信息, 并没有$x_{z_t}$ 处的位置信息, 被称之为<strong>请求流</strong>(Query Stream).</li></ul><h5 id="Content-Stream-and-Query-Stream"><a href="#Content-Stream-and-Query-Stream" class="headerlink" title="Content Stream and Query Stream"></a>Content Stream and Query Stream</h5><p>下面就来以论文中的图为例子, 看一下具体的双流注意力在场景中的结构.</p><p>第一层的Query Stream被定义为一个可训练的向量, 记作$g_i^{(0)}=w$, 设置Content Stream是对应的Embedding, 记作$h_i^{(0)}=e(x_i)$. Self - Attention层记为$m=1,\dots,M$.</p><p>XLNet的每一层与Transformer - XL相同, 包括FFN, Layer Norm, 残差连接, 多头注意力… 这些细节都暂时省略掉, 到后面我们会串起来看.</p><p>先来看看最熟悉的Self - Attention, 这与Transformer中是保持一致的, 不要忘记它也被称为内容流:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/xlnet4.jpg" style="zoom:50%"><p>Content Stream能使用<strong>包括其本身在内的所有上下文信息</strong>. 为了存储上下文信息, 所以Q依赖于上层对应位置的Content Stream, K和V均依赖于所有输入的隐态:<br>$$<br>h_{z_{t}}^{(m)} \leftarrow \text { Attention }\left(\mathrm{Q}=h_{z_{t}}^{(m-1)}, \mathrm{KV}=\mathbf{h}_{\mathrm{z} \leq t}^{(m-1)} ; \theta\right), \quad\left(\text {content stream: use both } z_{t} \text { and } x_{z_{t}}\right)<br>$$<br>下面来看看XLNet中独有的请求流$g_\theta$:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/xlnet5.jpg" style="zoom:50%"><p>因为只用于<strong>发起请求</strong>, 请求流的Q只能由上一层的Query Stream生成, 而K和V不能使用当前位置的内容信息, 所以只能由<strong>其他位置</strong>的上下文信息决定:<br>$$<br>g_{z_{t}}^{(m)} \leftarrow \text { Attention }\left(\mathrm{Q}=g_{z_{t}}^{(m-1)}, \mathrm{KV}=\mathbf{h}_{\mathrm{z}&lt;t}^{(m-1)} ; \theta\right), \quad \text { (query stream: use } z_{t} \text { but cannot see } \left.x_{z_{t}}\right)<br>$$<br>对比一下Query Stream和Content Stream, 二者的不同点主要在<strong>Q的依赖来源</strong>和能否使用<strong>上层当前位置的内容信息</strong> $h_{z=t}^{(m-1)}$:<br>$$<br>\begin{aligned}<br>&amp;g_{z_{t}}^{(m)} \leftarrow \text { Attention }\left(\mathrm{Q}=g_{z_{t}}^{(m-1)}, \mathrm{KV}=\mathbf{h}_{\mathrm{z}&lt;t}^{(m-1)} ; \theta\right), \quad \text { (query stream: use } z_{t} \text { but cannot see } \left.x_{z_{t}}\right)\\<br>&amp;h_{z_{t}}^{(m)} \leftarrow \text { Attention }\left(\mathrm{Q}=h_{z_{t}}^{(m-1)}, \mathrm{KV}=\mathbf{h}_{\mathrm{z}&lt;t}^{(m-1)} ; \theta\right), \quad\left(\text {content stream: use both } z_{t} \text { and } x_{z_{t}}\right)<br>\end{aligned}<br>$$</p><h5 id="Permutation-Attention-Mask"><a href="#Permutation-Attention-Mask" class="headerlink" title="Permutation Attention Mask"></a>Permutation Attention Mask</h5><p>其实我们也不用做真正意义上的置换, 只需要将Attention中的<strong>Mask机制</strong>结合起来使用就好, 如下图:</p><img src="https://gitee.com/Daning0/Images/raw/master/MLDL/xlnet6.jpg" style="zoom:50%"><p>图中的白点代表被Mask, 红点代表可以被Attend.</p><p>置换后的顺序为$3\rightarrow2\rightarrow4\rightarrow1$ 时, 请求流是不能看到当前正在预测的Token的内容信息的, 所以请求流矩阵<strong>主对角线</strong>一定都是被Mask的. 因为第一个要预测的就是位置$3$ 的内容, 所以矩阵第三行全都被Mask. 在预测出位置$3$ 后的内容后, 在请求流矩阵第二行的第三列就变得已知了. 在预测位置$4$ 和$1$ 时同理.</p><p>当搞懂了请求流矩阵后, 再看内容流矩阵, 完全符合我们之前对这两种流的定义: <strong>内容流矩阵不过是请求流矩阵主对角线没被Mask而已</strong>, 因为请求流的要求是当前要预测的内容不可知, 内容流却只是存储上下文, 没有这种限制.</p><h5 id="Particial-Prediction"><a href="#Particial-Prediction" class="headerlink" title="Particial Prediction"></a>Particial Prediction</h5><p>在实验过程中, 发现如果对所有置换后的序列输入进行预测, 会导致<strong>收敛缓慢</strong>, 难以优化. 作者只去预测置换后序列的<strong>最后几个</strong>Token, 这样置换后序列$\mathbf{z}$ 就被分成了两个部分, 分别是分割点$c$ 前的$\mathbf{z}_{\leq c}$, 和<strong>需要预测</strong>的分割点后的序列$\mathbf{z}_{&gt;c}$. 根据这个变化, XLNet的优化目标变为:<br>$$<br>\max _{\theta} \mathbb{E}_{\mathbf{z} \sim \mathcal{Z}_{T}}\left[\log p_{\theta}\left(\mathbf{x}_{\mathbf{z}&gt;c} \mid \mathbf{x}_{\mathbf{z} \leq c}\right)\right]=\mathbb{E}_{\mathbf{z} \sim \mathcal{Z}_{T}}\left[\sum_{t=c+1}^{|\mathbf{z}|} \log p_{\theta}\left(x_{z_{t}} \mid \mathbf{x}_{\mathbf{z}&lt;t}\right)\right]<br>$$</p><p>关于分割点, 作者假设了超参数$K$, 设$|\mathbf{z}| /(|\mathbf{z}|-c) \approx K$. 有$\frac{1}{K}$ 个Token需要被预测, 不需要预测的Token所对应的Query Stream是不需要被计算的, 这样能够节省计算资源.</p><h5 id="Integrate-Attention-into-Transformer-Backbone"><a href="#Integrate-Attention-into-Transformer-Backbone" class="headerlink" title="Integrate Attention into Transformer Backbone"></a>Integrate Attention into Transformer Backbone</h5><p>我们现在可以把除了双流Attention以外的结构加进来了, 仍然也都是Transformer中的组件, 只是位置编码采用的是<strong>相对位置编码</strong>(这里的相对位置编码和Transformer - XL还不一样, 后面会提及).</p><p>对于时间步$t=1,\dots,T$, 将含有相对位置编码的Attention记为$\text{RelAttn}$, 将Position - wise的Feed Forward记为$\text{PosFF}$, 整个双流Attention<strong>更新</strong>过程如下:<br>$$<br>\begin{array}{l}<br>\hat{h}_{z_{t}}^{(m)}=\text { LayerNorm }\left(h_{z_{t}}^{(m-1)}+\operatorname{RelAttn}\left(h_{z_{t}}^{(m-1)},\left[\tilde{\mathbf{h}}^{(m-1)}, \mathbf{h}^{(m-1)}_{\mathbf{z}_{\leq t}}\right]\right)\right) \\<br>h_{z_{t}}^{(m)}=\text { LayerNorm }\left(\hat{h}_{z_{t}}^{(m)}+\operatorname{PosFF}\left(\hat{h}_{z_{t}}^{(m)}\right)\right) \\<br>\hat{g}_{z_{t}}^{(m)}=\text { LayerNorm }\left(g_{z_{t}}^{(m-1)}+\operatorname{RelAttn}\left(g_{z_{t}}^{(m-1)},\left[\tilde{\mathbf{h}}^{(m-1)}, \mathbf{h}_{\mathbf{z}&lt;t}^{(m-1)}\right]\right)\right) \\<br>g_{z_{t}}^{(m)}=\text { LayerNorm }\left(\hat{g}_{z_{t}}^{(m)}+\operatorname{PosFF}\left(\hat{g}_{z_{t}}^{(m)}\right)\right)<br>\end{array}<br>$$</p><h3 id="Incorporating-Ideas-From-Transformer-XL"><a href="#Incorporating-Ideas-From-Transformer-XL" class="headerlink" title="Incorporating Ideas From Transformer - XL"></a>Incorporating Ideas From Transformer - XL</h3><p>因为Transformer - XL是最近颇有成效的AR模型, 所以作者尝试将它的两种最关键的技术<strong>相对编码</strong>和<strong>段级递归</strong>引入, 与XLNet结合. 作者引入了两种相对编码, Transformer - XL一模一样的<strong>相对位置编码</strong>和结合段问题添加的<strong>相对段编码</strong>.</p><h4 id="Segement-Level-Recurrence"><a href="#Segement-Level-Recurrence" class="headerlink" title="Segement Level Recurrence"></a>Segement Level Recurrence</h4><p>其实和Transformer - XL中的段级递归一样. 假设现在有两段长序列$\mathbf{s}$, $\tilde{\mathbf{x}}=\mathbf{s}_{1: T}$ 与 $\mathbf{x}=\mathbf{s}_{T+1: 2 T}$, 其置换后的序列分别是$\tilde{\mathbf{z}}=\text{Permutation}([1\cdots T])$ 和 $\mathbf{z}=\text{Permutation}([T+1\cdots 2T])$. 那么计算第二段$\mathbf{x}$的内容流可以按照如下方式更新:<br>$$<br>h_{z_{t}}^{(m)} \leftarrow \text { Attention }\left(\mathrm{Q}=h_{z_{t}}^{(m-1)}, \mathrm{KV}=\left[\tilde{\mathbf{h}}^{(m-1)}, \mathbf{h}_{\mathbf{z}_{\leq t}}^{(m-1)}\right] ; \theta\right)<br>$$<br>将Memory中缓存的隐态$\tilde{\mathbf{h}}^{(m-1)}$ 和$\mathbf{x}$ 产生的隐态$\mathbf{h}_{\mathbf{z}_{\leq t}}^{(m-1)}$ Concat起来, 一起计算K和V.</p><h4 id="Multiple-Segments"><a href="#Multiple-Segments" class="headerlink" title="Multiple Segments"></a>Multiple Segments</h4><p>XLNet与BERT一样, 在预训练阶段也是随机选择了两段连续或不连续的上下文合并到一起, 作为一个序列的两个Segment输入进XLNet中, 但只对连续内容使用Segment Memory. 两段之间采用的符号也和BERT类似, <code>[CLS, A, SEP, B, SEP]</code>.</p><h4 id="Relative-Segment-Encoding"><a href="#Relative-Segment-Encoding" class="headerlink" title="Relative Segment Encoding"></a>Relative Segment Encoding</h4><p>注意, 这是<strong>相对段编码</strong>而并非相对位置编码. XLNet中的段编码方式与BERT中的绝对段编码方式不同, XLNet采用相对段编码.</p><p>对于给定的序列位置$i$ 和 $j$, 当这两个位置都位于同一个Segment时, 令$s_{ij}=s_+$, 否则$s_{ij}=s_-$. 其中$s_+$ 和$s_-$ 是每个注意力头<strong>分别</strong>学习的. 这种编码只关注<strong>两个Token是否位于同个Segment内</strong>, 而并<strong>不考虑来自于哪个特定的Segment</strong>, 这个角度来看与相对编码的思想是保持一致的.</p><p>在计算注意力时, $i$ 对$j$ 的注意力是这样计算的:<br>$$<br>a_{i j}=\left(\mathbf{q}_{i}+\mathbf{b}\right)^{\top} \mathbf{s}_{i j}<br>$$<br>$q_i$ 是标准注意力计算来的Query Vector, $\mathbf{b}$ 是一个可学习的参数, 最后将这个注意力$a_{ij}$和正常的注意力<strong>相加</strong>得到最终的注意力.</p><p>相对编码增强了模型的泛化能力, 并提供了完成多段输入任务的可能性.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Transformer - XL结合了<strong>段循环</strong>和<strong>注意力机制</strong>, 缓解了Transformer受限于输入长度的问题, 也节省了计算资源的开销, 减少了不必要的计算. 并在段循环的基础上做出相对位置编码的改进.</p><p>XLNet用置换的方法将AE模型引以为傲的双向捕捉上下文能力移植到AR模型上, 将Transformer - XL的特性也组装到自己的模型中.</p><p>从大家对XLNet的看法来说, 它是<strong>饱受争议</strong>的. 虽然根据所给出的实验数据来说, XLNet能够取得比较好的效果, 但是对比BERT使用的13G数据, XLNet使用了158G数据, 而BERT才仅仅使用了13G数据, 到底是模型本身的方法导致效果好, 还是数据堆上去的, 我个人认为很难说. 后人基于XLNet所作出的后续研究非常少. 相反, BERT的魔改模型都快一窝了.</p><p>我记得前段时间还有人说XLNet完爆BERT, 大家吵得不可开交. 具体见<a href="https://zhuanlan.zhihu.com/p/74812464" target="_blank" rel="noopener">XLNet团队：只要公平对比，BERT毫无还手之力</a>(可能也有点标题党的嫌疑).</p><p>另外吐槽一下, 因为XLNet整篇论文特别碎, 也很乱, 所以才一直拖着, 毕竟写这篇博客实在是太费劲了. 虽然明确的指出了BERT确实存在的问题, 但XLNet解决方案不是很优雅, 感觉像一堆零件<strong>拼凑</strong>到了一起.</p><p>虽然XLNet诟病繁多, 但XLNet为AR模型实现双向上下文捕捉能力提供了可能, 这种带领大家突破BERT框架的思维模式还是很重要的..</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">AnNing</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://ADAning.github.io/posts/35276.html">https://ADAning.github.io/posts/35276.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">AnNing</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/NLP/"><span class="chip bg-color">NLP</span> </a><a href="/tags/Transformer/"><span class="chip bg-color">Transformer</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.mvaline-card{margin:1.5rem auto}.mvaline-card .card-content{padding:20px 20px 5px 20px}</style><div class="card mvaline-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="mvcomments" class="card-content" style="display:grid"></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/minivaline/MiniValine.min.js"></script><script>new MiniValine({el:"#mvcomments",appId:"M2K91TQqrwW698jR08LdugNz-gzGzoHsz",appKey:"b04G08nTf4B3kqCfOOY1urvC",mode:"xCss",placeholder:"评论暂不支持Latex公式, 但支持Markdown语法.",pathname:window.location.pathname,lang:"",adminEmailMd5:"ebbfbc84f11742e41a94a4e64b1d37ab",tagMeta:["管理员","小伙伴","访客"],master:["ebbfbc84f11742e41a94a4e64b1d37ab"],friends:["b5bd5d836c7a0091aa8473e79ed4c25e","adb7d1cd192658a55c0ad22a3309cecf","3ce1e6c77b4910f1871106cb30dc62b0","cfce8dc43725cc14ffcd9fb4892d5bfc"],math:!1,md:!0,enableQQ:!0,NoRecordIP:!1,visitor:!1,maxNest:6,pageSize:12,serverURLs:"",emoticonUrl:["https://cdn.jsdelivr.net/npm/alus@latest","https://cdn.jsdelivr.net/gh/MiniValine/qq@latest","https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest","https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest","https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest","https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"]})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/59193.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/featureimages/20.jpg" class="responsive-img" alt="AcrE: Atrous Convolution and Residual Embedding"> <span class="card-title">AcrE: Atrous Convolution and Residual Embedding</span></div></a><div class="card-content article-content"><div class="summary block-with-text">本文前置知识: 膨胀卷积(空洞卷积) 残差连接 Knowledge Graph Embedding with Atrous Convolution and Residual Learning本文是论文Knowledge Graph</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-10-27 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" class="post-category">知识图谱</a></span></div></div><div class="card-action article-tags"><a href="/tags/KGE/"><span class="chip bg-color">KGE</span> </a><a href="/tags/%E7%A9%BA%E6%B4%9E%E5%8D%B7%E7%A7%AF/"><span class="chip bg-color">空洞卷积</span> </a><a href="/tags/%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5/"><span class="chip bg-color">残差连接</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/3996.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/medias/featureimages/17.jpg" class="responsive-img" alt="ELMo, GPT, BERT"> <span class="card-title">ELMo, GPT, BERT</span></div></a><div class="card-content article-content"><div class="summary block-with-text">本文的前置知识: RNN Transformer Language Model ELMo, GPT, BERT本文是对ELMo, GPT, BERT三个模型的结构介绍以及个人理解, 多图预警. Introduction由于NLP领域</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-10-04 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/NLP/"><span class="chip bg-color">NLP</span> </a><a href="/tags/%E8%AF%8D%E5%90%91%E9%87%8F/"><span class="chip bg-color">词向量</span></a></div></div></div></div></article></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});const i="expanded";let c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).hide(),a.removeClass("l9")):(c.addClass(i).show(),a.addClass("l9"));{let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}return}})})</script></main><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2020</span> <a href="/about" target="_blank">AnNing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">301.6k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/ADAning" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:695439722@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="https://www.zhihu.com/people/nzhu-27" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/nzhu-27" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-angle-double-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io@master/libs/instantpage/instantpage.js" type="module"></script></body></html>