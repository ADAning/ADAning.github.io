<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="KMP算法, DaNing的博客"><meta name="description" content="DaNing的个人博客."><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>KMP算法 | DaNing的博客</title><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/favicon.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/css/matery.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/css/my.css"><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">DaNing的博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>时间轴</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-tools" style="zoom:.6"></i> <span>工具</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/shortcut"><i class="fas fa-rocket" style="margin-top:-20px;zoom:.6"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu"><i class="fas fa-wheelchair" style="margin-top:-20px;zoom:.6"></i> <span>帮你百度</span></a></li><li><a href="/markdown"><i class="fab fa-markdown" style="margin-top:-20px;zoom:.6"></i> <span>Markdown</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">DaNing的博客</div><div class="logo-desc">DaNing的个人博客.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-tools"></i> 工具 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/shortcut" style="margin-left:75px"><i class="fa fas fa-rocket" style="position:absolute;left:50px"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu" style="margin-left:75px"><i class="fa fas fa-wheelchair" style="position:absolute;left:50px"></i> <span>帮你百度</span></a></li><li><a href="/markdown" style="margin-left:75px"><i class="fa fab fa-markdown" style="position:absolute;left:50px"></i> <span>Markdown</span></a></li></ul></li></ul></div></div></nav></header><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/featureimages/20.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">KMP算法</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/%E7%BC%96%E7%A8%8B/"><span class="chip bg-color">编程</span> </a><a href="/tags/KMP/"><span class="chip bg-color">KMP</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E7%AE%97%E6%B3%95/" class="post-category">算法</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2020-09-02</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-03-27</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 3.2k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 12 分</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>字符串是一种<strong>特殊的线性表</strong>, 其逻辑结构与线性表相同, 只是在数据类型上进行了约束, 要求元素全是字符类型. 串可以顺序存储, 链式存储, 或者堆存储. 堆结合了顺序和链式的优点, 实际在构造串也是采用的堆结构来存储, 能够方便动态扩展.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/串1.jpg" style="zoom:50%"><p>方便理解可以使用顺序存储.</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 串的定义</span>
<span class="token comment" spellcheck="true">//typedef struct{</span>
<span class="token comment" spellcheck="true">//    char str[maxSize+1];</span>
<span class="token comment" spellcheck="true">//    int length; </span>
<span class="token comment" spellcheck="true">//}Str;</span>

<span class="token comment" spellcheck="true">// 或者</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>ch<span class="token punctuation">;</span>
    <span class="token keyword">int</span> length<span class="token punctuation">;</span>
<span class="token punctuation">}</span>Str<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串以<code>&#39;\0&#39;</code>作为<strong>结束标记</strong>. 串的基本操作有赋值, 取串长, 串比较, 求子串, 串清空, 串连接等. 在实现起来没有多大难度, 就稍微注意一下结束标记的处理即可.</p><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>对一个串中的某子串定位操作称为串的模式匹配, 而其中与主串进行对比的子串称为模式串. 在字符串中常用到字符串匹配.</p><h3 id="简单模式匹配算法"><a href="#简单模式匹配算法" class="headerlink" title="简单模式匹配算法"></a>简单模式匹配算法</h3><p>简单而朴素的匹配算法, 就是将主串与模式串的字符挨个进行比对, 如果相同则逐一比对主串和模式串的下一个元素, 如果不同, 则从主串的下一个元素重复逐个比对的过程. 全部相同则匹配成功, 否则匹配失败.</p><p>代码实现如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 简单模式匹配算法</span>
<span class="token comment" spellcheck="true">// 假设字符串储存在1 ~ length上 </span>
<span class="token keyword">int</span> <span class="token function">index</span><span class="token punctuation">(</span>Str str<span class="token punctuation">,</span> Str substr<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 其中i和j分别用来表示主串和子串的位置, k用来暂存主串被比对的位置 </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> str<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> substr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>i<span class="token punctuation">;</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span><span class="token punctuation">{</span>
            j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token operator">++</span>k<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 匹配失败 i从主串下一个位置开始 </span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 到这里有两种可能性 一个是原串被遍历完了 还有就是子串被遍历完了 </span>
    <span class="token comment" spellcheck="true">// 如果是子串遍历完了说明匹配成功 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> substr<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        <span class="token keyword">return</span> k<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为假设字符串从下标1开始, 0是没有字符的</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个简单的算法就是单纯的暴力匹配, 没有任何的预处理, 如果字符串长为n, 模式串长为m, 那么<strong>最坏时间复杂度为O((n-m+1)*m)</strong>. 即每次主串与模式串匹配时总能一直搜索到模式串的最后一个字符, 并最后匹配没有成功.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/串2.png" style="zoom:33%"><h3 id="KMP算法-1"><a href="#KMP算法-1" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>KMP算法是一种经典的字符串匹配算法, 相较于前面所说的简单字符串匹配算法, 在比较速度上有了相当大的提升.</p><p>来观察一个问题, 在下述串匹配过程中, 当在箭头所指的位置发生了字符不匹配:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp1.jpg" style="zoom:50%"><p>如果是简单字符串匹配算法, 那么很简单, 说明以主串第一个元素<code>A</code> 为起始的字符串无法与模式串相匹配, 将回溯到主串第二个元素<code>B</code> 与模式串第一个元素<code>A</code> 进行比较, 然后继续逐一比较下去…</p><p>继续观察如何才能使得模式串指针直接移动到再次能够与箭头所指的主串字符<code>B</code> 与模式串相比较的位置:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp2.jpg" style="zoom:50%"><p>由于主串第二个字符是<code>B</code>, 模式串第一个字符是<code>A</code>, 发生不匹配, 主串指针下移, 主串的第三四五个字符和模式串的第一二三个字符匹配, 又回到了对模式串某字符主串字符<code>B</code> 的比对.</p><p>除去简单字符串匹配, 有没有更取巧的办法, 利用<strong>模式串自身的特点</strong>, 或者说利用在主串和模式串发生不匹配时已经匹配字符的信息, 来压缩这个比较的过程呢?</p><p>继续逐一完成主串和模式串的比对, 又发现有一处不匹配.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp3.jpg" style="zoom:50%"><p>如果是简单字符串匹配又要逐一后移, 直到达到下述状态, 才能再次进行主串中所指的<code>B</code> 和模式串比对.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp4.jpg" style="zoom:50%"><p>经过这两个例子, 隐隐约约发现点问题. 总会出现一种状态, <strong>模式串中某个字符与主串字符发生不匹配, 但在这之前的所有字符都已经匹配了</strong>. 如果使用简单字符串匹配, 效率极其低下. 如果模式串的前半部分(从起始处向后取)和后半部分(从不匹配点向前取)有<strong>完全相同的子串</strong>, 那么很明显如果前半部分与主串完全匹配, 那么后半部分也一定与主串完全匹配, 那就不用重复进行比对了!</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp8.jpg" style="zoom:50%"><p>为方便比较, 我将两次比对放在一起, 比如:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp5.jpg" style="zoom:50%"> <img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp2.jpg" style="zoom:50%"><p>这里从起始处向后取, 即黄色框内的<code>ABA</code> 和从不匹配点向前取的白色框内的<code>ABA</code> 就是完全相同的子串, 这对子串称为<strong>公共前后缀</strong>. 正是因为这对前后缀完全相同, 所以发生字符不匹配时, 才能直接使得模式串的指针停留在前缀的下一个位置上, 不再重复进行前缀的比对, 这也是简单字符串匹配和KMP算法的最大不同, 即<strong>模式串的比较指针不回溯</strong>.</p><blockquote><p>指针不回溯意味着对大规模的外存中的字符串匹配操作可以分段进行. 先读入内存一部分进行匹配, 完成后再写回外存, 确保在匹配时不需要将之前写回外存的部分再次读入, 减少了IO操作, 从而提高了效率.</p></blockquote><p>在取前后缀时, 可能会有多对, 那应该取哪一对呢? 以上述发生不匹配的图为例, 从左右分别取, 应该可以形成<code>A-A</code>, <code>ABA-ABA</code>, <code>ABABA-ABABA</code> 三对符合要求的公共前后缀. 其中<code>AB-BA</code> 和 <code>ABAB-BABA</code>不是完全相同的子串, 是倒过来的, 不是公共前后缀. 如果要尽可能的减少重复比对次数, 一定是公共前后缀越长越好, 越长说明已经比对过的字符越多. 同时需要注意, <code>ABABA-ABABA</code> 这对是长度完全和子串长度相等, 再次比对时就失去了意义, 虽然是公共前后缀, 但它应该<strong>不能被使用</strong>. <code>ABA-ABA</code> 就是<strong>最长公共前后缀</strong>, 取最长的一对公共前后缀作为指针不回溯的依据.</p><p>记住, 模式串的比较指针直接就指向了前缀的下一个位置. 再看一个例子, 加深理解:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp6.jpg" style="zoom:50%"> <img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp4.jpg" style="zoom:50%"><p>在上述叙述的过程中, 发生主串和模式串的不匹配时, 模式串左侧与主串的对应位置一定是匹配的, 换句话说二者是一样的. 那么研究模式串就和研究主串是等价的了, 因此<strong>与主串无关</strong>, 仅保留模式串, 将指针不回溯的位置记录用数组下来, 当发生不匹配时, 指针就恢复到之前记录的位置即可. 这个数组称为<strong>next数组</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp7.jpg" style="zoom:50%"><p>为方便, 字符串下标从1开始. 对于模式串:</p><table><thead><tr><th align="center">发生不匹配的模式串下标</th><th align="center">最长公共前后缀长度</th><th align="center">主串当前与模式串比对的下标</th><th align="center">最长公共前后缀</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">0</td><td align="center">0(特殊)</td><td align="center">-</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">1</td><td align="center">-</td></tr><tr><td align="center">3</td><td align="center">0</td><td align="center">1</td><td align="center">-</td></tr><tr><td align="center">4</td><td align="center">1</td><td align="center">2</td><td align="center"><code>A</code></td></tr><tr><td align="center">5</td><td align="center">2</td><td align="center">3</td><td align="center"><code>AB</code></td></tr><tr><td align="center">6</td><td align="center">3</td><td align="center">4</td><td align="center"><code>ABA</code></td></tr><tr><td align="center">7</td><td align="center">1</td><td align="center">2</td><td align="center"><code>A</code></td></tr><tr><td align="center">8</td><td align="center">1</td><td align="center">2</td><td align="center"><code>A</code></td></tr><tr><td align="center">9</td><td align="center">2</td><td align="center">3</td><td align="center"><code>AB</code></td></tr><tr><td align="center">10</td><td align="center">3</td><td align="center">4</td><td align="center"><code>ABA</code></td></tr><tr><td align="center">11</td><td align="center">4</td><td align="center">5</td><td align="center"><code>ABAB</code></td></tr><tr><td align="center">12</td><td align="center">5</td><td align="center">6</td><td align="center"><code>ABABA</code></td></tr></tbody></table><p>总结上述规律, 除去模式串第一个元素外, 主串当前元素与模式串元素比对的下标是最长前后缀长度+1. 如果下标为1发生不匹配, 主串的下一个元素与模式串下标元素为1开始比较. 最坏时间复杂度是O(n+m).</p><h4 id="简单匹配升级到KMP"><a href="#简单匹配升级到KMP" class="headerlink" title="简单匹配升级到KMP"></a>简单匹配升级到KMP</h4><p>先抛开next数组如何构造不谈, 先看看如何写KMP的代码. 如果KMP完成了简单字符串匹配算法的压缩, 那也应该能够由简单算法升级为KMP算法.</p><p>实现KMP代码如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">KMP</span><span class="token punctuation">(</span>Str str<span class="token punctuation">,</span> Str substr<span class="token punctuation">,</span> <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 下标从1开始</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> substr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 主串指针下移的情况</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> str<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>i<span class="token punctuation">;</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 发生不匹配时模式串指针跳到next数组所指向的位置</span>
        <span class="token keyword">else</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 遍历完模式串没发现不匹配 说明模式串与主串相匹配</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">></span> substr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> i <span class="token operator">-</span> substr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h4><p>再来看看next数组是如何构建的. 让我们回到之前找最长公共前后缀的过程. 那时曾经说过, 公共前后缀是两段<strong>完全相同的子串</strong>, 那找最长公共前后缀的过程岂不是也是字符串匹配? 我们仍然要延续不重复做事情的思路, 利用已知信息去求next数组.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp9.jpg" style="zoom:50%"><p>如果这样去想, 那么图中Pj所对应的next数组的值与Pt必然是有关联的.</p><p>当Pj和Pt的大小未知, 而前面模式串均相同时, 假设在Pj出发生不匹配, 模式串指针会跳转到最长公共前后缀+1处, 即next[j] = t. 有了这个初始条件, 可以根据Pj和Pt的大小关系推出next[j+1].</p><p>假设P(j+1)处发生不匹配:</p><ul><li><p>如果Pj = Pt, 那么next[j+1] = next[j]+1 = t+1.</p></li><li><p>如果Pj != Pt, 就得在这两个串(本质是模式串自己) 中找到最长的公共前后缀, 也就<strong>回到了字符串匹配的问题中</strong>. 将P(j-t+1) ~ Pj 视为主串, P1 ~ Pt视为模式串, 继续做字符串匹配. 必须向前反复重定位指针, 找到一个位置使得Pj = Pt或满足t = 0, 即将t循环赋值为next[t], t = 0 时, 令next[j+1] = 1.</p><p>注意, 因为第二种情况与字符串匹配完全一致, 所以建立next数组的代码一定与KMP算法<strong>极其相似</strong>:</p></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 求next数组的方法 substr为模式串 </span>
<span class="token comment" spellcheck="true">// j和t与上述图中相同</span>
<span class="token keyword">void</span> <span class="token function">getNext</span><span class="token punctuation">(</span>Str substr<span class="token punctuation">,</span> <span class="token keyword">int</span> next<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    next<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> substr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// j&lt;= substr.length 会使next数组下标越界 </span>
        <span class="token comment" spellcheck="true">// 模式串自身匹配</span>
        <span class="token comment" spellcheck="true">// t可能被下面的else赋值为0, 在条件并入后会将t置为1</span>
        <span class="token comment" spellcheck="true">// 并且第一次执行, 有next[2] = 1, 满足之前推导的结果</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
            <span class="token operator">++</span>t<span class="token punctuation">;</span>
            next<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// next[j] = length+1 length实际上就是没++前的t</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> t <span class="token operator">=</span> next<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模式串指针重定位到next[t] </span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="KMP算法改进"><a href="#KMP算法改进" class="headerlink" title="KMP算法改进"></a>KMP算法改进</h4><p>在求next数组时, 会一直用到向”前反复重定位指针”这个操作, 还可以有优化的余地.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp10.jpg" style="zoom:50%"><p>在这个例子中出现了<strong>连续且完全相同的字符</strong>, 在j = 5时发生不匹配, next[j] = 4, 将j重定位到next[j] 上. j又为4, next[j] 又为3… 反复重定位, 直到j为0, 才发现该位置的主串和模式串完全不匹配, 主串和模式串指针都应该后移一位. 在这个过程, 从1到4位置上的字符串是相等的, 应该直接给next[5] 赋值为0.</p><p>尝试在next数组的基础上, 构建一个重定向数组, 使得其能够根据之前比较的内容跳过多余的比较, 直接将next[j] 赋值为某个已知的next数组值, 这个数组叫<strong>nextval数组</strong>.</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp11.jpg" style="zoom:50%"><p>在上面的图中, j位置的元素反复与Pd, Pc, Pb, Pa都进行了比较, 但明显前三者都是冗余比较, 不能给解决不匹配问题带来好处. 此处的nextval[j] 应该为a.</p><p>推广到一般情况, 路径上的元素都不是相邻的, 而现在j之前的nextval数组值都是已知的, 如何求j后的元素k的nextval[k] 呢?</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/DS/kmp12.jpg" style="zoom:50%"><p>如果k位置上的元素和j位置上的元素相等, 那么nextval[k] = nextval[next[k]], 如果不相等则令nextval[k] = next[k].</p><p>归纳为一般步骤:</p><ol><li>j = 1时, nextval[j] 赋值为 0, 作为特殊标记</li><li>j &gt; 1时:<ul><li>若Pj != P(next[j]), 则nextval[j] = next[j].</li><li>若Pj = P(next[j]), 则nextval[j] = nextval[next[j]].</li></ul></li></ol><p>求nextval数组的代码可以由求next数组的代码修改而来, 最好对比结合起来看, 实现如下:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getNextval</span><span class="token punctuation">(</span>Str substr<span class="token punctuation">,</span> <span class="token keyword">int</span> nextval<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    nextval<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// j=1时nextval[j] = 0</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;</span> substr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>j<span class="token punctuation">;</span>
            <span class="token operator">++</span>t<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 求解next数组时, 有next[j] = t; 那么t可以代替next[j] </span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> substr<span class="token punctuation">.</span>ch<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span>
                nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nextval[j] = next[j]</span>
            <span class="token keyword">else</span>
                nextval<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nextval<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// nextval[j] = nextval[next[j]]</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> t <span class="token operator">=</span> nextval<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">AnNing</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://ADAning.github.io/posts/35921.html">https://ADAning.github.io/posts/35921.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">AnNing</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/%E7%BC%96%E7%A8%8B/"><span class="chip bg-color">编程</span> </a><a href="/tags/KMP/"><span class="chip bg-color">KMP</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.mvaline-card{margin:1.5rem auto}.mvaline-card .card-content{padding:20px 20px 5px 20px}</style><div class="card mvaline-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="mvcomments" class="card-content" style="display:grid"></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/minivaline/MiniValine.min.js"></script><script>new MiniValine({el:"#mvcomments",appId:"M2K91TQqrwW698jR08LdugNz-gzGzoHsz",appKey:"b04G08nTf4B3kqCfOOY1urvC",mode:"xCss",placeholder:"评论暂不支持Latex公式, 但支持Markdown语法.",pathname:window.location.pathname,lang:"",adminEmailMd5:"ebbfbc84f11742e41a94a4e64b1d37ab",tagMeta:["管理员","小伙伴","访客"],master:["ebbfbc84f11742e41a94a4e64b1d37ab"],friends:["b5bd5d836c7a0091aa8473e79ed4c25e","adb7d1cd192658a55c0ad22a3309cecf","3ce1e6c77b4910f1871106cb30dc62b0","cfce8dc43725cc14ffcd9fb4892d5bfc"],math:!1,md:!0,enableQQ:!0,NoRecordIP:!1,visitor:!1,maxNest:6,pageSize:12,serverURLs:"",emoticonUrl:["https://cdn.jsdelivr.net/npm/alus@latest","https://cdn.jsdelivr.net/gh/MiniValine/qq@latest","https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest","https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest","https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest","https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"]})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/35661.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/featureimages/14.jpg" class="responsive-img" alt="别再对类别变量独热编码"> <span class="card-title">别再对类别变量独热编码</span></div></a><div class="card-content article-content"><div class="summary block-with-text">不要再对类别变量独热编码本文参考了Stop One-Hot Encoding Your Categorical Variables, 并对其内容在加以自身理解的情况下进行翻译. 独热编码对不同的类别变量就需要用到独热编码, 独热编码是将类别</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-09-04 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="post-category">机器学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"><span class="chip bg-color">特征工程</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/40071.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/featureimages/6.jpg" class="responsive-img" alt="Seq2Seq和Attention"> <span class="card-title">Seq2Seq和Attention</span></div></a><div class="card-content article-content"><div class="summary block-with-text">2020.09.25: 本质部分的猜想被证实. 2020.09.21: 更新Attention的本质. 2020.09.19: 在接触了更多NLP内容后, 发现Attention是一个有特殊表征意义的结构, 以后会加入更深的理解. Se</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2020-08-25 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/Attention/"><span class="chip bg-color">Attention</span> </a><a href="/tags/RNN/"><span class="chip bg-color">RNN</span></a></div></div></div></div></article></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});const i="expanded";let c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).hide(),a.removeClass("l9")):(c.addClass(i).show(),a.addClass("l9"));{let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}return}})})</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2020</span> <a href="/about" target="_blank">AnNing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">348k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/ADAning" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:695439722@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="https://www.zhihu.com/people/nzhu-27" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/nzhu-27" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-angle-double-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/instantpage/instantpage.js" type="module"></script></body></html>