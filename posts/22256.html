<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="PURE: A Frustratingly Easy Approach for Entity and Relation Extraction, DaNing的博客"><meta name="description" content="DaNing的个人博客."><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>PURE: A Frustratingly Easy Approach for Entity and Relation Extraction | DaNing的博客</title><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/favicon.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/css/matery.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/css/my.css"><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">DaNing的博客</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>时间轴</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-tools" style="zoom:.6"></i> <span>工具</span> <i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/shortcut"><i class="fas fa-rocket" style="margin-top:-20px;zoom:.6"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu"><i class="fas fa-wheelchair" style="margin-top:-20px;zoom:.6"></i> <span>帮你百度</span></a></li><li><a href="/markdown"><i class="fab fa-markdown" style="margin-top:-20px;zoom:.6"></i> <span>Markdown</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">DaNing的博客</div><div class="logo-desc">DaNing的个人博客.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-tools"></i> 工具 <span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul><li><a href="/shortcut" style="margin-left:75px"><i class="fa fas fa-rocket" style="position:absolute;left:50px"></i> <span>导航(待完善)</span></a></li><li><a href="/helpyoubaidu" style="margin-left:75px"><i class="fa fas fa-wheelchair" style="position:absolute;left:50px"></i> <span>帮你百度</span></a></li><li><a href="/markdown" style="margin-left:75px"><i class="fa fab fa-markdown" style="position:absolute;left:50px"></i> <span>Markdown</span></a></li></ul></li></ul></div></div></nav></header><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/cryptojs/crypto-js.min.js"></script><script></script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/featureimages/1.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">PURE: A Frustratingly Easy Approach for Entity and Relation Extraction</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{margin:35px 0 15px 0;padding-left:17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{height:calc(100vh - 250px);overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/ERE/"><span class="chip bg-color">ERE</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2021-12-01</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2022-10-13</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 3.3k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 13 分</div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><h1 id="A-Frustratingly-Easy-Approach-for-Entity-and-Relation-Extraction"><a href="#A-Frustratingly-Easy-Approach-for-Entity-and-Relation-Extraction" class="headerlink" title="A Frustratingly Easy Approach for Entity and Relation Extraction"></a>A Frustratingly Easy Approach for Entity and Relation Extraction</h1><p>本文是论文<a href="https://arxiv.org/abs/2010.12812" target="_blank" rel="noopener">A Frustratingly Easy Approach for Entity and Relation Extraction</a> 的阅读笔记和个人理解. 论文来自<strong>NAACL 2021</strong>. 本文为RTE问题中, 探讨NER和RE任务间关系的系列三部曲中的第二篇.</p><h2 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h2><p>最近的工作对NER和RE引入了联合训练, 即将NER和RE在多任务学习下一起解决. 并且联合模型经常使用同一个<strong>共享</strong>的Encoder解码, 解决问题的效果也都还不错, 这使得人们认为共享Encoder能够更好的解决这两个任务, 且认为联合模型能<strong>缓解错误误差传递</strong>的问题.</p><p>作者认为, <strong>Pipeline模型不一定真弱于联合学习模型</strong>. 因此希望构建一个简单的Pipeline模型来击败联合学习模型的SOTA, 来打破人们的固有观念.</p><h2 id="PURE"><a href="#PURE" class="headerlink" title="PURE"></a>PURE</h2><p><strong>PURE</strong>(the <strong>P</strong>rinceton <strong>U</strong>niversity <strong>R</strong>elation <strong>E</strong>xtraction system)简单的分为<strong>实体模型</strong>和<strong>关系模型</strong>两部分, 训练时完全分开训练. 因为是<strong>Pipeline</strong>, 所以关系模型使用实体的<strong>Golden Label</strong>训练.</p><p>用如下一张图可以简单概括:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure1.jpg" style="zoom:50%"><ul><li>(a) <strong>实体模型</strong>: 根据Span的表示, 判断给定的Span的实体类型.</li><li>(b) <strong>关系模型</strong>: 根据Span对的表示, 判断给定的Span对的关系类型.</li><li>(c) <strong>批计算的关系模型</strong>: 关系模型的一种加速实现.</li></ul><h3 id="Problem-Definition"><a href="#Problem-Definition" class="headerlink" title="Problem Definition"></a>Problem Definition</h3><p>本文所采用的方法是基于Span的方法, 因此给出基于Span的视角下问题的定义和NER, RE的定义.</p><p>对于给输入句子$X$ 含有$n$ 个Token$x_1, x_2, \dots, x_n$. 令$S$ 为$X$ 中的长度为$L$ 的Span集合, 即$S=\{s_1, s_2, \dots, s_m\}$, $\mathrm{START}(i), \mathrm{END}(i)$ 分别代表$s_i$ 的起始和结束切片Token.</p><ul><li>NER: 对于预定义的实体类型集合$\mathcal{E}$, 基于Span的NER任务为判断每个Span $s_i \in S$ 的实体类型$y_e(s_i) \in \mathcal{E}$, 若Span不是实体, 则记为$y_e(s_i) = \epsilon$. 任务的最终输出为$Y_e=\set{(s_i, e): s_i \in S, e \in \mathcal{E}}$.</li><li>RE: 对于预定义的关系类型集合$\mathcal{R}$, RE任务为判断每个Span对$s_i\in S, s_j \in S$ 之间的关系类型$y_r(s_i, s_j) \in \mathcal{R}$, 若Span对之间不存在关系, 则记为$y_r(s_i, s_j) = \epsilon$. 任务最终输出为$Y_r = \set{(s_i, s_j, r): s_i, s_j \in S, r \in \mathcal{R}}$.</li></ul><h3 id="Entity-Model"><a href="#Entity-Model" class="headerlink" title="Entity Model"></a>Entity Model</h3><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure9.png" style="zoom:60%"><p>实体模型简单的建模为基于<strong>Span</strong>的模型, 先用BERT获得输入Token $x_t$ 的上下文表示$\mathbf{x}_t$, 对于某个Span $s_i \in S$, 它的表示如下:</p><p>$$<br>\mathbf{h}_{e}\left(s_{i}\right)=\left[\mathbf{x}_{\mathrm{START}(i)} ; \mathbf{x}_{\mathrm{END}(i)} ; \phi\left(s_{i}\right)\right]<br>$$</p><p>其中, $\phi{(s_i)}$ 为Span长度的Embedding.</p><blockquote><p>Span的表示仅简单的使用了Span<strong>边界</strong>以及Span<strong>长度</strong>信息, 而非把Span内部所有信息全部囊括. 基于Span的模型经常只使用边界上的信息, 可能是假设边界蕴含的语义更强.</p></blockquote><p>在得到Span表示$\mathbf{h}_{e}\left(s_{i}\right)$ 后, 直接用一个FeedForward Network就能预测得到实体类型的概率分布:<br>$$<br>P_{e}\left(e \mid s_{i}\right)=\operatorname{softmax}\left(\mathbf{W}_{e} \mathrm{FFNN}\left(\mathbf{h}_{e}\left(s_{i}\right)\right)\right.<br>$$</p><h3 id="Relation-Model"><a href="#Relation-Model" class="headerlink" title="Relation Model"></a>Relation Model</h3><p>在实体模型得到了实体的Span $s_i, s_j$ 的表示$\mathbf{h}_e(s_i), \mathbf{h}_e(s_j)$ 后, 也直接接一个FeedForward Network就能预测Span间关系类型.</p><p>但作者认为, 实体模型得到的边界表示只能捕获每个<strong>单独实体</strong>周围的上下文信息, 没法感知到<strong>Span之间</strong>的依存信息, 而这种依存信息是对RE非常重要的.</p><p>所以, 作者在Span周围插入了独立的Text Marker指导模型获得Span间的依存关系:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure10.png" style="zoom:60%"><p>具体来说, 对于给定的输入句子$X$ 和<strong>每个</strong>存在$e_i, e_j \in \mathcal{E} \cup \set{\epsilon}$ 的Subject - Object Span对$s_i, s_j$, 定义了四种类型的Text Marker, $\left\langle\mathrm{S}: e_{i}\right\rangle,\left\langle/ \mathrm{S}: e_{i}\right\rangle, \left\langle\mathrm{O}: e_{j}\right\rangle,\left\langle/ \mathrm{O}: e_{j}\right\rangle$, 分别插入到Subject的前后和Object的前后.</p><blockquote><p>这种Text Marker除了提供了Subject和Object的角色信息, 实体边界信息, 还提供了实体类型信息.</p></blockquote><p>即插入Text Marker后的输入序列$\widehat{X}$ 为:<br>$$<br>\begin{aligned}<br>&amp;\widehat{X}=\ldots\left\langle\operatorname{S}: e_{i}\right\rangle, x_{\operatorname{START}(i)}, \ldots, x_{\operatorname{END}(i)},\left\langle/ \mathrm{S}: e_{i}\right\rangle \\<br>&amp;\ldots\left\langle\mathrm{O}: e_{j}\right\rangle, x_{\mathrm{START}(j)}, \ldots, x_{\mathrm{END}(j)},\left\langle/ \mathrm{O}: e_{j}\right\rangle, \ldots<br>\end{aligned}<br>$$</p><blockquote><p>注意, 这种Type Marker对于每个Subject - Object Span对都是在最初输入文本$X$ 上重新插入的, <strong>每个不同的Span对都能生成一个不同的输入文本</strong>$\widehat{X}$. 这在关系判断阶段引入了巨大的计算量, 作者在后文对这一点进行了改进.</p></blockquote><p>接着使用不同于实体模型的第二个Encoder捕获关系模型下Subject和Object的表示:<br>$$<br>\mathbf{h}_{r}\left(s_{i},s_{j}\right)=\left[\widehat{\mathbf{x}}_{\widehat{\operatorname{START}}(i)} ; \widehat{\mathbf{x}}_{\widehat{\operatorname{START}}(j)}\right]<br>$$</p><p>$\widehat{\operatorname{START}}(i), \widehat{\operatorname{START}}(j)$ 为$\left\langle\mathrm{S}: e_{i}\right\rangle, \left\langle\mathrm{O}: e_{j}\right\rangle$ 的在$\widehat{X}$ 的下标.</p><blockquote><p>仅使用Text Marker的<strong>起始</strong>作为Subject和Object的表示, 在这里结束位置信息仅作为区分实体是否结束的标志.</p></blockquote><p>同样的, 在表示后面用一个FeedForward Network来预测关系类型:<br>$$<br>P_{r}\left(r \mid s_{i}, s_{j}\right)=\operatorname{softmax}\left(\mathbf{W}_{r} \mathbf{h}_{r}\left(s_{i}, s_{j}\right)\right)<br>$$</p><h3 id="Cross-sentence-context"><a href="#Cross-sentence-context" class="headerlink" title="Cross - sentence context"></a>Cross - sentence context</h3><p>跨句信息对预测实体类型和关系是有帮助的.</p><p>作者简单的使用固定大小为$W$ 的<strong>滑动窗口</strong>, 来获取更长的上下文. 假设输入句子有$n$ 个单词, 则滑动窗口可以分别获得左侧和右侧的$(W - n) / 2$ 个单词作为额外上下文.</p><h3 id="Training-amp-inference"><a href="#Training-amp-inference" class="headerlink" title="Training &amp; inference"></a>Training &amp; inference</h3><p>两个模型分别用交叉熵优化即可:</p><p>$$<br>\begin{aligned}<br>&amp;\mathcal{L}_{e}=-\sum_{s_{i} \in S} \log P_{e}\left(e_{i}^{\ast} \mid s_{i}\right) \\<br>&amp;\mathcal{L}_{r}=-\sum_{s_{i}, s_{j} \in S_{G}, s_{i} \neq s_{j}} \log P_{r}\left(r_{i, j}^{\ast} \mid s_{i}, s_{j}\right)<br>\end{aligned}<br>$$</p><p>$e_i^\ast$ 为$s_i$ 的真实实体类型, $r_{i, j}^\ast$ 为$s_i, s_j$ 间的真实关系类型.</p><h3 id="Differences-from-DYGIE"><a href="#Differences-from-DYGIE" class="headerlink" title="Differences from DYGIE++"></a>Differences from DYGIE++</h3><p>作者的方法与DYGIE++非常相似, 因此在这里强调了与它的不同:</p><ol><li>作者用两个独立的Encoder分别做NER和RE任务, 而非用MTL(Multi - task Learning)的角度去看待.并且关系模型所需的实体类型信息能完全产生于实体模型.</li><li>引入了Text Marker, 在关系模型中Span对的表示不同.</li><li>使用跨句信息, 而不是使用Beam Search和图网络.</li></ol><h3 id="Efficient-Batch-Computations"><a href="#Efficient-Batch-Computations" class="headerlink" title="Efficient Batch Computations"></a>Efficient Batch Computations</h3><p>在加入Type Marker时, 每个实体对都有不同的$\widehat{X}$, 即使输入的原句子$X$ 相同, 也会因为Type Marker的位置, 类型不同而必须重新计算<strong>整句表示</strong>, 这种计算开销实在是太大了, 所以作者提出了一种加速的<strong>近似模型</strong>.</p><p>首先, 把所有Text Marker全部添加到句子的尾部, 并令Text Marker与实体的起始位置, 结束位置的Position Embedding共享:<br>$$<br>\begin{aligned}<br>&amp;\mathrm{P}\left(\left\langle\mathrm{S}: e_{i}\right\rangle\right), \mathrm{P}\left(\left\langle/ \mathrm{S}: e_{i}\right\rangle\right):=\mathrm{P}\left(x_{\mathrm{START}(i)}\right), \mathrm{P}\left(x_{\mathrm{END}(i)}\right) \\<br>&amp;\mathrm{P}\left(\left\langle\mathrm{O}: e_{j}\right\rangle\right), \mathrm{P}\left(\left\langle/ \mathrm{O}: e_{j}\right\rangle\right):=\mathrm{P}\left(x_{\mathrm{START}(j)}\right), \mathrm{P}\left(x_{\mathrm{END}(j)}\right)<br>\end{aligned}<br>$$</p><p>$P(\cdot)$ 代表取Token的位置ID.</p><p>然后, 对Attention Layer添加约束, 强制Text Token只能Pay Attention to Text, 不能对Marker分配注意力权重, 而Marker Token可以对所有Token分配注意力.</p><blockquote><p>这样就能拿到一组<strong>纯净</strong>而<strong>共享</strong>的Text表示, Text表示没有Type Marker干预.</p></blockquote><p>给出一个例子:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure11.png" style="zoom:60%"><p>图中Text Marker均位于句子尾部, 并且<code>mor</code> 和<code>[S:Md]</code> 共享相同的Position Embedding, <code>##pa</code> 和<code>[/S:Md]</code> 共享相同的Position Embedding.</p><p>在运行RE模型的时候, 因为<strong>Text Token表示不再与Marker Token相关</strong>, 所以不用重复计算Text的表示, 直接用Marker表示可以<strong>一次性计算句子中所有的实体对之间的关系</strong>, 把同一个句子中的所有实体对的关系预测完全压缩到单个句子中.</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p>实验中使用的数据集是ACE04, ACE05, SciERC, 统计数据如下:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure3.jpg" style="zoom:40%"><h3 id="Main-Results"><a href="#Main-Results" class="headerlink" title="Main Results"></a>Main Results</h3><p>在上述三个数据集上的结果如下:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure2.jpg" style="zoom:40%"><p>♣代表引入跨句, †代表引入额外数据. 结果中L = LSTM, L + E = LSTM + Elmo, Bb = BERT - base, Bl = BERT - large, SciB = SciBERT(规模与Bert - base相同), ALB = ALBERT - xxlarge - v1. Rel为实体边界准确且关系准确, Rel+为实体边界和实体类型, 关系均准确.</p><p>其中Wang and Lu是<a href="https://adaning.github.io/posts/37252.html">TSE</a> 的结果. ALBERT下的PURE比TSE性能要好一点. Wadden是DYGIE++的结果.</p><p>在单句情况下PURE达到了SOTA, 在跨句情况下更是比单句要高上一层.</p><h3 id="Batch-Computations-and-Speedup"><a href="#Batch-Computations-and-Speedup" class="headerlink" title="Batch Computations and Speedup"></a>Batch Computations and Speedup</h3><p>近似的关系模型效果如下:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure4.jpg" style="zoom:40%"><p>近似模型基本上掉了一个点左右, 但是耗时有明显下降.</p><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h4 id="Importance-of-Typed-Text-Markers"><a href="#Importance-of-Typed-Text-Markers" class="headerlink" title="Importance of Typed Text Markers"></a>Importance of Typed Text Markers</h4><p>不同类型的Type Markers也对关系模型性能有着影响, 在ACE05和SciERC上结果如下:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure5.jpg" style="zoom:40%"><p>gold为使用Golden Entity, e2e代表端到端, 也就是训练时直接使用实体模型的结果.</p><p>上表对应了6种输入关系模型前的Span表示方法:</p><ul><li><strong>TEXT</strong>: 直接用原Text的每个实体的的起始Token Embedding.</li><li><strong>TEXTETYPE</strong>: 在TEXT基础上拼接Entity Type Embedding.</li><li><strong>MARKERS</strong>: 使用不包含实体类型的边界Text Marker的Embedding.</li><li><strong>MARKERSETYPE</strong>: 在MARKERS基础上拼接实体类型Embedding.</li><li><strong>MARKERSELOSS</strong>: 使用不包含实体类型的边界Text Marker Embedding, 并引入一个辅助Loss, 用边界表示判断实体类型.</li><li><strong>TYPEDMARKERS</strong>: 正文中所使用的方法.</li></ul><p>能看到, 不同类型的Type Markers前前后后能差出四个点来, 增益非常大.</p><h4 id="Modeling-Entity-Relation-Interactions"><a href="#Modeling-Entity-Relation-Interactions" class="headerlink" title="Modeling Entity-Relation Interactions"></a>Modeling Entity-Relation Interactions</h4><p>作者探究了共享Encoder对性能的影响, 在ACE05上结果如下:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure7.jpg" style="zoom:40%"><p>当两个模型共享Encoder联合优化时, 性能都有下降, 解释为两个任务形式不同, 使用面向单一任务的单一Encoder比共享要专一. <strong>简单的共享Encoder对作者的方法无益</strong>.</p><blockquote><p>作者在论文脚注处写到, 某些方法的作者提到共享Encoder有提升.</p><p>论文中的用词很严谨, 一是”简单共享”, 二是”对我们模型没有好处”, 个人认为对于大多数模型共享是否有害还无法一锤定音.</p><p>但是再想想, 如果使用纯Pipeline不共享Encoder, 那就有了两个独立的Encoder, 相对于共享一个Encoder来说, 多了一倍预训练参数, 涨一点性能上去是理所应当的吧?</p></blockquote><h4 id="Mitigating-Error-Propagation"><a href="#Mitigating-Error-Propagation" class="headerlink" title="Mitigating Error Propagation"></a>Mitigating Error Propagation</h4><p>误差的错误传播在联合抽取中一直是没有被解决的问题, 正是因为这一问题, 才提出的联合抽取模型.</p><p>作者探究了关系模型采用实体模型预测出来的实体, 而不是Golden Entity时的F1:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure6.jpg" style="zoom:40%"><p>10 - way jackkniﬁng就是十折交叉, 即为把数据划分成十份, 并且每个模型都用其中9份训练, 预测最后1份, 每个模型都对应着1份的预测结果, 把它们作为关系模型的输入, 然后训练关系模型.</p><p>结果表明使用实体模型的预测结果不如使用Golden Entity训练, 解释为实体模型的预测为关系模型在训练时带来了更多的噪声, 导致性能下降. Pipeline的曝光偏差影响或许并不像我们想的那样.</p><p>作者尝试召回更多实体, 把实体模型输出分数最高的40%作为关系模型的输入, 然后用Beam Search得到结果, 发现F1仍在下降. 结果并没有表明误差错误传播的问题存在, 同时召回更多实体在训练时也会引入更多的<strong>噪声</strong>, 因为关系模型还需要判断Span是不是实体.</p><h4 id="Effect-of-Cross-sentence-Context"><a href="#Effect-of-Cross-sentence-Context" class="headerlink" title="Effect of Cross - sentence Context"></a>Effect of Cross - sentence Context</h4><p>作者研究了滑动窗口大小$W$ 对模型性能的影响:</p><img src="https://cdn.jsdelivr.net/gh/ADAning/Image/MLDL/pure8.jpg" style="zoom:40%"><p>$W=100$ 后提升不大, 甚至对关系模型有负面影响.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>本篇论文主要指出了基于Pipeline的模型不一定要弱于已经存在的联合抽取模型. 属于”逆行者”类论文. 在印象中, Pipeline性能是要弱于joint模型的, 因为其误差错误传播问题比较大.</p><p>本文使用两个极其<strong>简单</strong>且<strong>完全没有交互</strong>的Encoder, 用基于<strong>Span</strong>的<strong>Pipeline</strong>模型达到了联合抽取模型的SOTA效果, 并指出关系模型中的效率问题, 给出了一个近似实现. 此外, 针对联合抽取任务中Pipeline模型存在的偏见做出了探究, 奇怪的是误差的错误传播在本模型中并没有得到体现.</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者: </i></span><span class="reprint-info"><a href="/about" rel="external nofollow noreferrer">AnNing</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接: </i></span><span class="reprint-info"><a href="https://ADAning.github.io/posts/22256.html">https://ADAning.github.io/posts/22256.html</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明: </i></span><span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/about" target="_blank">AnNing</a> !</span></div></div><script async defer>function navToReprintStatement(){$("html, body").animate({scrollTop:$("#reprint-statement").offset().top-80},800)}document.addEventListener("copy",function(t){M.toast({html:'<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>'})})</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/ERE/"><span class="chip bg-color">ERE</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="qq,wechat,weibo" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/share/js/social-share.min.js"></script></div></div></div></div></div><style>.mvaline-card{margin:1.5rem auto}.mvaline-card .card-content{padding:20px 20px 5px 20px}</style><div class="card mvaline-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="mvcomments" class="card-content" style="display:grid"></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/minivaline/MiniValine.min.js"></script><script>new MiniValine({el:"#mvcomments",appId:"M2K91TQqrwW698jR08LdugNz-gzGzoHsz",appKey:"b04G08nTf4B3kqCfOOY1urvC",mode:"xCss",placeholder:"评论暂不支持Latex公式, 但支持Markdown语法.",pathname:window.location.pathname,lang:"",adminEmailMd5:"ebbfbc84f11742e41a94a4e64b1d37ab",tagMeta:["管理员","小伙伴","访客"],master:["ebbfbc84f11742e41a94a4e64b1d37ab"],friends:["b5bd5d836c7a0091aa8473e79ed4c25e","adb7d1cd192658a55c0ad22a3309cecf","3ce1e6c77b4910f1871106cb30dc62b0","cfce8dc43725cc14ffcd9fb4892d5bfc"],math:!1,md:!0,enableQQ:!0,NoRecordIP:!1,visitor:!1,maxNest:6,pageSize:12,serverURLs:"",emoticonUrl:["https://cdn.jsdelivr.net/npm/alus@latest","https://cdn.jsdelivr.net/gh/MiniValine/qq@latest","https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest","https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest","https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest","https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"]})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/27457.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/featureimages/1.jpg" class="responsive-img" alt="PFN: A Partition Filter Network for Joint Entity and Relation Extraction"> <span class="card-title">PFN: A Partition Filter Network for Joint Entity and Relation Extraction</span></div></a><div class="card-content article-content"><div class="summary block-with-text">本文前置知识: RNN: 详见循环神经网络小结. A Partition Filter Network for Joint Entity and Relation Extraction本文是论文A Partition Filter</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2022-01-12 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/ERE/"><span class="chip bg-color">ERE</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/37252.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="Two are Better than One: Joint Entity and Relation Extraction with Table - Sequence Encoders"> <span class="card-title">Two are Better than One: Joint Entity and Relation Extraction with Table - Sequence Encoders</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Two are Better than One: Joint Entity and Relation Extraction with Table - Sequence Encoders本文是论文Two are Better than One</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2021-11-16 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></span></div></div><div class="card-action article-tags"><a href="/tags/ERE/"><span class="chip bg-color">ERE</span></a></div></div></div></div></article></div><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/codeBlock/codeShrink.js"></script><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre!important}</style></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/tocbot/tocbot.min.js"></script><script>$(function(){tocbot.init({tocSelector:"#toc-content",contentSelector:"#articleContent",headingsOffset:-(.4*$(window).height()-45),collapseDepth:Number("0"),headingSelector:"h2, h3, h4"});let t=0,e="toc-heading-",n=($("#toc-content a").each(function(){$(this).attr("href","#"+e+ ++t)}),t=0,$("#articleContent").children("h2, h3, h4").each(function(){$(this).attr("id",e+ ++t)}),parseInt(.4*$(window).height()-64)),o=$(".toc-widget");$(window).scroll(function(){$(window).scrollTop()>n?o.addClass("toc-fixed"):o.removeClass("toc-fixed")});const i="expanded";let c=$("#toc-aside"),a=$("#main-content");$("#floating-toc-btn .btn-floating").click(function(){c.hasClass(i)?(c.removeClass(i).hide(),a.removeClass("l9")):(c.addClass(i).show(),a.addClass("l9"));{let e=$("#artDetail");if(0!==e.length){let t=e.width();450<=t?t+=21:350<=t&&t<450?t+=18:300<=t&&t<350?t+=16:t+=14,$("#prenext-posts").width(t)}return}})})</script></main><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]}}</script><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2020</span> <a href="/about" target="_blank">AnNing</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">361.6k</span>&nbsp;字 <span id="busuanzi_container_site_pv">|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 </span><span id="busuanzi_container_site_uv">|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人</span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/ADAning" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:695439722@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="https://www.zhihu.com/people/nzhu-27" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/nzhu-27" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/js/search.js"></script><script type="text/javascript">$(function(){searchFunc("https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-angle-double-up"></i></a></div><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js",(e=document.getElementsByTagName("script")[0]).parentNode.insertBefore(t,e)}()</script><script async src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/ADAning/ADAning.github.io/libs/instantpage/instantpage.js" type="module"></script></body></html>